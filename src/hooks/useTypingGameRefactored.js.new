'use client';

/**
 * useTypingGameRefactored.js
 * タイピングゲームの統合カスタムフック
 * リファクタリング版 - モジュール分割と責任の明確化
 */

import { useState, useEffect, useCallback, useRef } from 'react';
import { useTypingCore } from './typing/useTypingCore';
import { useTypingInput } from './typing/useTypingInput';
import { useTypingStats } from './typing/useTypingStats';
import TypingUtils from '@/utils/TypingUtils';

const DEFAULT_SOUND_SYSTEM = {
  playSound: () => { }, // 無効なデフォルト実装
};

/**
 * タイピングゲームの統合カスタムフック
 * 3つの専門フックを組み合わせて、完全なタイピングゲーム体験を提供
 * 
 * @param {Object} options タイピングゲームの設定オプション
 * @param {Object} options.initialProblem 初期問題
 * @param {boolean} options.playSound 効果音を再生するかどうか
 * @param {Object} options.soundSystem サウンドシステム
 * @param {Function} options.onProblemComplete 問題完了時のコールバック
 * @param {Function} options.onDebugInfoUpdate デバッグ情報更新のコールバック
 * @returns {Object} タイピングゲームの状態と操作メソッド
 */
export function useTypingGameRefactored(options = {}) {
  const {
    initialProblem = null,
    playSound = true,
    soundSystem = DEFAULT_SOUND_SYSTEM,
    onProblemComplete = () => { },
    onLastKeyPress = () => { },
    onDebugInfoUpdate = null,
  } = options;

  // デバッグ情報
  const debugInfoRef = useRef({});

  // 進捗更新の最小閾値（パーセント）
  const PROGRESS_UPDATE_THRESHOLD = 5;
  
  // 統計情報管理
  const typingStats = useTypingStats({
    onStatsUpdate: (stats) => {
      // デバッグ情報の更新
      if (onDebugInfoUpdate) {
        const debugInfo = {
          ...debugInfoRef.current,
          stats,
        };
        debugInfoRef.current = debugInfo;
        onDebugInfoUpdate(debugInfo);
      }
    }
  });

  /**
   * 問題状態変更時の処理
   */
  const handleProblemStateChange = useCallback(({ type, progress }) => {
    if (type === 'completed') {
      // 問題完了時の統計処理
      console.log('[useTypingGameRefactored] 問題完了: 統計情報を記録します');
      
      const statsData = typingStats.recordProblemCompletion();
      
      console.log('[useTypingGameRefactored] 記録された統計情報:', statsData);

      // コールバック呼び出し - 詳細なデータを渡す
      onProblemComplete({
        problemKeyCount: statsData.problemKeyCount || 0,
        problemElapsedMs: statsData.problemElapsedMs || 0,
        problemKPM: statsData.problemKPM || 0,
        updatedProblemKPMs: statsData.updatedProblemKPMs || [],
        problemStats: statsData.allProblems || [],
        // 従来版と互換性を持たせるために必要なデータを確実に含める
        problemMistakeCount: statsData.problemMistakeCount || 0,
        stats: typingStats.statsRef.current
      });
    }
  }, [onProblemComplete, typingStats]);

  /**
   * コアタイピング機能
   */
  const typingCore = useTypingCore({
    initialProblem,
    onProblemStateChange: handleProblemStateChange,
    onSessionInitialized: (session) => {
      // セッション初期化時の追加処理
      console.log('[useTypingGameRefactored] セッション初期化: 統計情報をリセット');
      
      // 新しいセッション開始時にタイマー開始
      const now = Date.now();
      typingStats.resetStats();
      
      // 開始時間を設定
      typingStats.statsRef.current.startTime = now;
      typingStats.statsRef.current.currentProblemStartTime = now;
    },
  });

  /**
   * 入力処理
   */
  const typingInput = useTypingInput({
    sessionRef: typingCore.sessionRef,
    isCompleted: typingCore.isCompleted,
    completedRef: typingCore.completedRef,
    playSound,
    soundSystem,
    onKeyInput: (result) => {
      // 入力成功時
      if (result.success) {
        typingStats.countCorrectKey(result.timestamp);
        if (result.completed) return; // 完了時は追加処理なし
      } 
      // 入力失敗時
      else if (result.failed) {
        typingStats.countMistake();
      }
      
      // 最後に押されたキーを通知
      if (result.key) {
        onLastKeyPress(result.key);
      }
    },
  });

  /**
   * 問題設定
   */
  const setProblem = useCallback(
    (problem) => {
      if (!problem) return;

      console.log('[useTypingGameRefactored] 新しい問題を設定:', {
        displayText: problem.displayText?.substring(0, 20) + '...',
        kanaText: problem.kanaText?.substring(0, 20) + '...'
      });

      // コアに問題を設定
      typingCore.setProblem(problem);
    },
    [typingCore]
  );

  /**
   * キー入力処理（外部から呼び出し可能）
   */
  const handleInput = useCallback(
    (key) => {
      return typingInput.processKeyInput(key);
    },
    [typingInput]
  );

  /**
   * TypeScript向けにタイプ定義を追加したオブジェクト
   * @type {Object}
   */
  return {
    // ステート
    problem: typingCore.problem,
    typingProgress: typingCore.typingProgress,
    completionPercentage: typingCore.completionPercentage,
    isCompleted: typingCore.isCompleted,
    typingSession: typingCore.sessionRef.current,
    typingSessionRef: typingCore.sessionRef,
    typingStats: typingStats,
    displayStats: typingStats.displayStats,
    
    // コントロールメソッド
    setProblem,
    handleInput,
    getCurrentExpectedKey: () => typingCore.sessionRef.current?.getCurrentExpectedKey() || '',
    
    // パフォーマンス測定
    performanceMetrics: debugInfoRef.current,
  };
}
