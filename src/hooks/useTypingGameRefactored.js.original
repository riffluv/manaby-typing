'use client';

/**
 * useTypingGameRefactored.js
 * タイピングゲームの統合カスタムフック - メインスレッド処理優先版
 * リファクタリング版 - モジュール分割と責任の明確化
 * 2025年5月11日: WebWorkerからメインスレッド処理への移行開始
 */

import { useState, useEffect, useCallback, useRef } from 'react';
import { useTypingCore } from './typing/useTypingCore';
import { useTypingInput } from './typing/useTypingInput';
import { useTypingStats } from './typing/useTypingStats';
import TypingUtils from '@/utils/TypingUtils';
import { 
  processTypingInputOnMainThread, 
  getColoringInfoOnMainThread, 
  getNextExpectedKeyOnMainThread 
} from '../utils/TypingProcessorMain';

const DEFAULT_SOUND_SYSTEM = {
  playSound: () => { }, // 無効なデフォルト実装
};

// デバッグログフラグ
const DEBUG = process.env.NODE_ENV === 'development' && false;

/**
 * タイピングゲームの統合カスタムフック（メインスレッド優先版）
 * メインスレッドとWorkerを併用して、パフォーマンスと即時性を両立
 * 
 * @param {Object} options タイピングゲームの設定オプション
 * @param {Object} options.initialProblem 初期問題
 * @param {boolean} options.playSound 効果音を再生するかどうか
 * @param {Object} options.soundSystem サウンドシステム
 * @param {Function} options.onProblemComplete 問題完了時のコールバック
 * @param {Function} options.onDebugInfoUpdate デバッグ情報更新のコールバック
 * @returns {Object} タイピングゲームの状態と操作メソッド
 */
export function useTypingGameRefactored(options = {}) {
  const {
    initialProblem = null,
    playSound = true,
    soundSystem = DEFAULT_SOUND_SYSTEM,
    onProblemComplete = () => { },
    onDebugInfoUpdate = null,
  } = options;

  // デバッグ情報
  const debugInfoRef = useRef({});

  // 進捗更新の最小閾値（パーセント）
  const PROGRESS_UPDATE_THRESHOLD = 5;

  /**
   * 問題状態変更時の処理
   */  const handleProblemStateChange = useCallback(({ type, progress }) => {
    if (type === 'completed') {
      const statsData = typingStats.recordProblemCompletion();

      // コールバック呼び出し
      onProblemComplete({
        problemKeyCount: statsData.problemKeyCount,
        problemElapsedMs: statsData.problemElapsedMs,
        problemKPM: statsData.problemKPM,
        updatedProblemKPMs: [], // statsDataから正しく取得できない場合はからの配列を設定
        problemStats: [] // statsDataから正しく取得できない場合はからの配列を設定
      });

      // デバッグログ出力
      console.log('[handleProblemStateChange] 問題完了時の統計:', statsData);
    }
  }, [onProblemComplete]);

  /**
   * コアタイピング機能
   */
  const typingCore = useTypingCore({
    initialProblem,
    onProblemStateChange: handleProblemStateChange,
    onSessionInitialized: (session) => {
      // セッション初期化時の追加処理
      typingStats.resetStats();
    },
  });

  /**
   * 統計情報管理
   */
  const typingStats = useTypingStats({
    onStatsUpdate: (stats) => {
      // デバッグ情報の更新
      if (onDebugInfoUpdate) {
        const debugInfo = {
          ...debugInfoRef.current,
          stats,
        };
        debugInfoRef.current = debugInfo;
        onDebugInfoUpdate(debugInfo);
      }
    }
  });

  /**
   * 入力処理
   */  const typingInput = useTypingInput({
    sessionRef: typingCore.sessionRef,
    isCompleted: typingCore.isCompleted,
    completedRef: typingCore.completedRef,
    playSound,
    soundSystem,
    // 問題完了時に呼び出されるコールバック
    onComplete: (inputData) => {
      // 状態を完了に設定
      typingCore.markAsCompleted();

      // 問題統計情報を記録し、上位コールバックに渡す
      const stats = typingStats.recordProblemCompletion();

      // 現在のミス数を明示的に取得
      const rawTypingStats = typingStats.statsRef.current || {};
      const mistakeCount = rawTypingStats.mistakeCount || 0;

      // パラメータ準備（シンプルにする）
      const typingStatsData = {
        problemKeyCount: stats.problemKeyCount || 0,
        problemElapsedMs: stats.problemElapsedMs || 0,
        problemKPM: stats.problemKPM || 0,
        problemMistakeCount: stats.problemMistakeCount || 0,
        displayStats: typingStats.displayStats,
        // 累計ミス数を直接取得
        totalMistakes: mistakeCount
      };

      console.log('[useTypingGameRefactored] 問題完了 - 統計情報:', {
        ...typingStatsData,
        直接取得したミス数: mistakeCount,
        表示用ミス数: typingStats.displayStats.mistakeCount
      });

      // 上位レイヤーに完了を通知
      if (typeof options.onComplete === 'function') {
        options.onComplete(typingStatsData);
      } else {
        console.log('[useTypingGameRefactored] 注意: onCompleteコールバックが定義されていません');
      }
    },
    onCorrectInput: ({ key, displayInfo, progress }) => {
      // 表示情報の更新
      typingCore.setDisplayInfo(displayInfo);

      // 大きな進捗変化があるときのみ更新
      if (Math.abs(progress - typingCore.progressPercentage) >= PROGRESS_UPDATE_THRESHOLD) {
        typingCore.setProgressPercentage(progress);
      }

      // 統計情報を更新
      typingStats.countCorrectKey(Date.now());

      // デバッグ情報の更新
      if (onDebugInfoUpdate) {
        debugInfoRef.current = {
          ...debugInfoRef.current,
          lastKey: key,
          displayInfo,
          progress,
        };
        onDebugInfoUpdate(debugInfoRef.current);
      }
    }, onIncorrectInput: ({ key }) => {
      // 統計情報を更新
      typingStats.countMistake();

      // ミスカウント後の情報をログ出力
      const mistakeCount = typingStats.statsRef.current?.mistakeCount || 0;
      console.log('[useTypingGameRefactored] ミス入力を検出:', {
        key,
        現在のミス数: mistakeCount,
        表示用ミス数: typingStats.displayStats.mistakeCount
      });

      // デバッグ情報の更新
      if (onDebugInfoUpdate) {
        debugInfoRef.current = {
          ...debugInfoRef.current,
          lastErrorKey: key,
          mistakeCount: mistakeCount
        }; onDebugInfoUpdate(debugInfoRef.current);
      }
    },
  });
  /**
   * 問題設定メソッド
   */
  const setProblem = useCallback((problem) => {
    console.log('[useTypingGameRefactored] 問題を設定します:', {
      displayText: problem?.displayText?.substring(0, 20) + '...',
      kanaText: problem?.kanaText?.substring(0, 20) + '...'
    });
    return typingCore.initializeSession(problem);
  }, [typingCore]);

  /**
   * 次の入力キーを取得
   */
  const getNextKey = useCallback(() => {
    return typingCore.getExpectedNextKey();
  }, [typingCore]);
  
  /**
   * メインスレッド優先のキー入力処理ハンドラ
   * WebWorker処理を待たずに即時応答性を向上させる
   */
  const handleInputWithMainThread = useCallback((char) => {
    if (typingCore.isCompleted) return { success: false, reason: 'already_completed' };
    
    // 処理開始時間を記録（パフォーマンス測定用）
    const startTime = performance.now();
    
    try {
      // 現在のセッションを取得
      const session = typingCore.sessionRef.current;
      if (!session) return { success: false, reason: 'no_session' };
      
      // メインスレッドで処理を実行
      const result = processTypingInputOnMainThread(session, char);
      
      // 処理時間を計測
      const processTime = performance.now() - startTime;
      
      // デバッグ情報を更新
      if (DEBUG) {
        console.log(`[MainThread] タイピング処理時間: ${processTime.toFixed(2)}ms`, result);
        debugInfoRef.current.mainThreadProcessTime = processTime;
        if (onDebugInfoUpdate) onDebugInfoUpdate(debugInfoRef.current);
      }
      
      if (result.success) {
        // 成功時の処理
        
        // セッションの状態を更新
        if (result.newState) {
          Object.assign(session, result.newState);
        }
        
        // 効果音再生
        if (playSound) {
          soundSystem.playSound('keypress');
        }
        
        // 色分け情報の取得（メインスレッドで高速処理）
        const colorInfo = getColoringInfoOnMainThread(session);
        
        // 表示情報の更新
        const displayInfo = {
          romaji: colorInfo.romaji || '',
          typedLength: colorInfo.typedLength || 0,
          currentInputLength: colorInfo.currentInputLength || 0,
          currentCharIndex: colorInfo.currentCharIndex || 0,
          currentInput: colorInfo.currentInput || '',
          expectedNextChar: colorInfo.expectedNextChar || '',
          currentCharRomaji: colorInfo.currentCharRomaji || '',
        };
        
        // 進捗の計算
        const progress = session.getCompletionPercentage?.() || Math.floor((session.currentCharIndex / (session.patterns?.length || 1)) * 100);
        
        // 表示情報を更新
        typingCore.setDisplayInfo(displayInfo);
        
        // 進捗情報を更新（大きな変化がある場合のみ）
        if (Math.abs(progress - typingCore.progressPercentage) >= PROGRESS_UPDATE_THRESHOLD) {
          typingCore.setProgressPercentage(progress);
        }
        
        // 統計情報を更新
        typingStats.countCorrectKey(Date.now());
        
        // 完了チェック
        if (result.newState?.completed || session.completed) {
          typingCore.markAsCompleted();
          const stats = typingStats.recordProblemCompletion();
          if (onProblemComplete) {
            onProblemComplete(stats);
          }
        }
        
        return { success: true, displayInfo, progress };
      } else {
        // 失敗時の処理（Workerによる処理にフォールバック）
        if (!result.alreadyCompleted) {
          // 効果音再生
          if (playSound) {
            soundSystem.playSound('keypress_error');
          }
          
          // ミスとしてカウント
          typingStats.countMistake();
          
          // 元のハンドラを呼び出す
          return typingInput.handleInput(char);
        }
        
        return { success: false, reason: result.error || 'incorrect_input' };
      }
    } catch (error) {
      console.error('[MainThread] タイピング処理エラー:', error);
      
      // エラー発生時はフォールバックでWorkerを使用
      return typingInput.handleInput(char);
    }
  }, [
    typingCore, 
    typingInput, 
    typingStats, 
    playSound, 
    soundSystem, 
    onProblemComplete,
    onDebugInfoUpdate
  ]);

  /**
   * 公開API
   */
  return {
    // 状態
    isInitialized: typingCore.isInitialized,
    isCompleted: typingCore.isCompleted,
    displayInfo: typingCore.displayInfo || {
      romaji: '',
      typedLength: 0,
      currentInputLength: 0,
      currentCharIndex: 0,
    },
    displayStats: typingStats.displayStats || {},
    progressPercentage: typingCore.progressPercentage || 0,
    errorAnimation: typingInput.errorAnimation || false,
    lastPressedKey: typingInput.lastPressedKey || '',

    // タイピングセッション参照（直接アクセス用）
    typingSession: typingCore.sessionRef.current,
    typingSessionRef: typingCore.sessionRef,

    // typingStatsオブジェクト全体を公開
    typingStats,

    // 統計参照を直接公開（アクセスしやすいように）
