/**
 * Enhanced Canvas Rendering Engine for High-Performance Typing Game
 *
 * 拡張バージョン（2025年5月17日）
 * タイピングゲーム専用のCanvas描画エンジン
 * - 問題テキスト表示とタイピング状態表示に特化
 * - 単一Canvasでの効率的な描画処理
 * - レイヤー概念はコンテキスト内部で処理
 */

// デバッグモード設定
const DEBUG = process.env.NODE_ENV === 'development';

// 固定サイズ設定（最適化のため）
const DEFAULT_SETTINGS = Object.freeze({
  width: 800,
  height: 600,
  fontFamily: "'SF Mono', Monaco, Consolas, monospace",
  fontSize: 24,
  backgroundColor: '#1a1a1a',
  textColor: '#ffffff',
  typedColor: '#88FF88', // 入力済み文字の色
  highlightColor: '#FFB41E', // 入力中の文字の色
  errorColor: '#ff3333', // エラー時の色
  nextCharColor: '#88FF88', // 次の文字の色
  keyboardHeight: 200,
  animationDuration: 150, // ms
  showErrorHighlight: false, // エラー表示のオン/オフを制御するフラグ
  // パフォーマンス設定
  useOffscreenCanvas: true,
  useImageCaching: true,
  preRenderChars: true,
  useRequestAnimationFrame: true,
  // レイヤー設定
  enableBackgroundLayer: true, // 背景レイヤーの有効化
  enableKeyboardLayer: true, // キーボードレイヤーの有効化
});

/**
 * CanvasTypingEngineクラス
 * タイピングゲーム専用のCanvas描画エンジン
 */
export default class CanvasTypingEngine {
  /**
   * コンストラクタ
   * @param {Object} options 設定オプション
   */
  constructor(options = {}) {
    // 設定の統合
    this.settings = { ...DEFAULT_SETTINGS, ...options };

    // キャンバス要素と2D描画コンテキスト
    this.canvas = null;
    this.ctx = null;

    // オフスクリーンキャンバス
    this.offscreenCanvas = null;
    this.offscreenCtx = null;

    // 静的コンテンツ用のオフスクリーンキャンバス
    this.staticBackgroundCanvas = null;
    this.staticBackgroundCtx = null;
    this.staticKeyboardCanvas = null;
    this.staticKeyboardCtx = null;

    // プリレンダリングされた文字のキャッシュ
    this.charCache = new Map();

    // アニメーション管理
    this.animationFrameId = null;
    this.isAnimating = false;
    this.lastRenderTime = 0;
    this.frameCount = 0;
    this.fps = 0;

    // ゲーム状態参照
    this.gameState = null;

    // キーフォーカス管理用の状態
    this.partialKeys = ''; // 現在入力中のローマ字
    this.currentFocus = ''; // 現在フォーカス中のキー(次に期待されるキー)

    // 描画制御フラグ
    this._needsRender = true; // 描画が必要かどうかのフラグ
    this._lastRenderTime = 0; // 最終描画時刻
    this._staticContentRendered = false; // 静的コンテンツが描画済みか

    // バインディング
    this._renderFrame = this._renderFrame.bind(this);
    this.render = this.render.bind(this);
    this._renderBackgroundLayer = this._renderBackgroundLayer.bind(this);
    this._renderProblemLayer = this._renderProblemLayer.bind(this);
    this._renderKeyboardLayer = this._renderKeyboardLayer.bind(this);
  }

  /**
   * キャンバスエンジンの初期化
   * @param {HTMLCanvasElement} canvas ターゲットキャンバス要素
   * @param {Object} gameState ゲーム状態
   * @returns {CanvasTypingEngine} このインスタンス（メソッドチェーン用）
   */
  initialize(canvas, gameState = {}) {
    if (!canvas || !(canvas instanceof HTMLCanvasElement)) {
      throw new Error('有効なcanvas要素が必要です');
    }

    // キャンバス設定
    this.canvas = canvas;
    this.ctx = canvas.getContext('2d', {
      alpha: false,
      desynchronized: true, // レイテンシ低減のため
    });

    // ゲーム状態設定
    this.gameState = gameState;

    // キャンバスサイズ設定 - ピクセル比を考慮
    this._setupCanvasSize();

    // 静的コンテンツ用のオフスクリーンキャンバスを作成
    if (this.settings.useOffscreenCanvas) {
      this._createOffscreenCanvases();
    }

    // プリレンダリング文字セット（最適化のため）
    if (this.settings.preRenderChars) {
      this._preRenderCharSet();
    }

    // キーハンドリングをバインド
    this._bindKeyHandlers();

    return this; // メソッドチェーン用
  }

  /**
   * キャンバスサイズの設定 - DPI問題対応のためdevicePixelRatioを使用しない
   * @private
   */
  _setupCanvasSize() {
    const { width, height } = this.settings;
    // DPIスケーリングの問題解決のため、devicePixelRatioを使用しない

    // キャンバス内部バッファサイズ設定（1:1の比率で設定）
    this.canvas.width = width;
    this.canvas.height = height;

    // CSS表示サイズ設定
    this.canvas.style.width = `${width}px`;
    this.canvas.style.height = `${height}px`;

    // スケール設定なし - 1:1マッピングを維持
    this.ctx.setTransform(1, 0, 0, 1, 0, 0);

    // デフォルト描画スタイル設定
    this.ctx.textBaseline = 'middle';
    this.ctx.textAlign = 'left';
    this.ctx.imageSmoothingEnabled = false; // ピクセルアートのクリアな表示用

    // フォントを設定（読み込み確実性のため）
    document.fonts.ready.then(() => {
      this.render(); // フォント読み込み後に再描画
    });
  }

  /**
   * オフスクリーンキャンバスの作成（最適化）
   * @private
   */
  _createOffscreenCanvases() {
    // メインのオフスクリーンキャンバス
    if (!this.offscreenCanvas) {
      this.offscreenCanvas = document.createElement('canvas');
      this.offscreenCanvas.width = this.canvas.width;
      this.offscreenCanvas.height = this.canvas.height;
      this.offscreenCtx = this.offscreenCanvas.getContext('2d', {
        alpha: false,
      });
    }

    // 背景用の静的オフスクリーンキャンバス
    if (this.settings.enableBackgroundLayer && !this.staticBackgroundCanvas) {
      this.staticBackgroundCanvas = document.createElement('canvas');
      this.staticBackgroundCanvas.width = this.canvas.width;
      this.staticBackgroundCanvas.height = this.canvas.height;
      this.staticBackgroundCtx = this.staticBackgroundCanvas.getContext('2d', {
        alpha: false,
      });
    }

    // キーボード用の静的オフスクリーンキャンバス
    if (this.settings.enableKeyboardLayer && !this.staticKeyboardCanvas) {
      this.staticKeyboardCanvas = document.createElement('canvas');
      this.staticKeyboardCanvas.width = this.canvas.width;
      this.staticKeyboardCanvas.height = this.canvas.height * 0.3; // キーボードの高さは画面の30%
      this.staticKeyboardCtx = this.staticKeyboardCanvas.getContext('2d', {
        alpha: true,
      });
    }
  }

  /**
   * アニメーションループの開始
   * @returns {CanvasTypingEngine} このインスタンス
   */
  startAnimation() {
    if (this.isAnimating) return this;

    this.isAnimating = true;
    this.lastRenderTime = performance.now();
    this._needsRender = true; // 初回描画を強制
    this.animationFrameId = requestAnimationFrame(this._renderFrame);

    return this;
  }

  /**
   * アニメーションループの停止
   * @returns {CanvasTypingEngine} このインスタンス
   */
  stopAnimation() {
    if (!this.isAnimating) return this;

    this.isAnimating = false;
    if (this.animationFrameId) {
      cancelAnimationFrame(this.animationFrameId);
      this.animationFrameId = null;
    }

    return this;
  }

  /**
   * ゲーム状態の更新
   * @param {Object} newState 新しいゲーム状態
   */
  updateGameState(newState) {
    // 変更前の状態を保存（差分検出用）
    const prevState = this.gameState ? { ...this.gameState } : {};

    // 新しい状態をマージ
    this.gameState = { ...this.gameState, ...newState };

    // 重要な状態変化があったかチェック（差分検出）
    const hasImportantChange =
      prevState.romaji !== this.gameState.romaji ||
      prevState.typedLength !== this.gameState.typedLength ||
      prevState.isError !== this.gameState.isError ||
      prevState.currentInput !== this.gameState.currentInput;

    // 表示に関わる状態変更があった場合、描画フラグをセット
    if (hasImportantChange) {
      this._needsRender = true;
      // 描画は次のrequestAnimationFrameに任せる
    }
  }

  /**
   * キー入力処理（状態更新のみ）
   * @param {string} key - 入力されたキー
   * @param {boolean} isCorrect - 正解かどうか
   */
  handleKeyInput(key, isCorrect = true) {
    // パフォーマンス測定の残骸を削除
    // 状態更新のみを行う（描画は行わない）
    if (this.gameState) {
      // エラー状態の更新
      // 部分入力がある場合は、そのキー入力が正しいかどうかを判定
      // 部分入力中は基本的にエラーフラグを立てない（途中の正しい入力はエラーではない）
      this.gameState.isError = !isCorrect;

      // 正解の場合は部分入力を更新（新しいロジックでは単純化）
      if (isCorrect && key) {
        // 次の文字が期待されるキーと一致する場合、入力を進める
        const expectedPos = this.gameState.typedLength || 0;
        if (expectedPos < this.gameState.romaji?.length) {
          // ここでは部分入力を直接更新せず、gameStateに必要な情報のみ保持
          this.gameState.currentInput = key;
        }
      }
    }

    // 描画フラグを立てる（次のrequestAnimationFrameで描画される）
    this._needsRender = true;
  }

  /**
   * 入力状態のリセット（ローマ字確定時）
   */
  resetInputState() {
    // 状態をリセット
    if (this.gameState) {
      // エラー状態をリセット
      this.gameState.isError = false;

      // 現在の入力をクリア
      this.gameState.currentInput = '';
    }

    // 描画フラグを立てる（次のフレームで描画）
    this._needsRender = true;
  }

  /**
   * エラー状態のリセット
   */
  resetErrorState() {
    if (this.gameState) {
      this.gameState.isError = false;
      // エラー後に確実に再描画する
      this._needsRender = true;
      // 強制的に即時レンダリングを実行
      this.render(true);
    }
  }

  /**
   * 描画の実行 - 外部からの呼び出し用
   * 実際の描画は requestAnimationFrame のサイクルで行われる
   * @param {boolean} forceRender - アニメーション状態に関わらず強制描画する場合はtrue
   * @returns {CanvasTypingEngine} このインスタンス
   */
  render(forceRender = false) {
    // 描画フラグを立てるだけ - 実際の描画はrequestAnimationFrameのタイミングで行う
    this._needsRender = true;

    // アニメーションが停止していて強制描画が必要な場合のみ、1フレームだけ描画
    if (!this.isAnimating && forceRender) {
      this.animationFrameId = requestAnimationFrame(this._renderFrame);
    }

    return this;
  }
  /**
   * レンダリングフレーム - requestAnimationFrameで呼び出される
   * @param {number} timestamp 現在のタイムスタンプ
   * @private
   */
  _renderFrame(timestamp) {
    // アニメーションが停止している場合は処理しない
    if (!this.isAnimating) return;

    // FPS計算（デバッグ用）
    this._updateFPS(timestamp);

    // 再描画の必要性を判断
    const needsRender = this._shouldRender(timestamp);

    if (needsRender) {
      // 実際の描画処理
      this._renderContents(timestamp);

      // 最終描画時刻を更新
      this._lastRenderTime = timestamp;
    }

    // 次のフレームをリクエスト
    this.animationFrameId = requestAnimationFrame(this._renderFrame);
  }

  /**
   * 描画の実行 - 外部からの呼び出し用
   * 実際の描画は requestAnimationFrame のサイクルで行われる
   * @param {boolean} forceRender - アニメーション状態に関わらず強制描画する場合はtrue
   * @returns {CanvasTypingEngine} このインスタンス
   */
  render(forceRender = false) {
    // 描画フラグを立てるだけ - 実際の描画はrequestAnimationFrameのタイミングで行う
    this._needsRender = true;

    // アニメーションが停止していて強制描画が必要な場合のみ、1フレームだけ描画
    if (!this.isAnimating && forceRender) {
      this._renderContents(performance.now());
    }

    return this;
  }

  /**
   * 実際の描画処理 - レイヤー別に描画を管理
   * @param {number} timestamp 現在のタイムスタンプ
   * @private
   */
  _renderContents(timestamp) {
    // キャンバスのクリア
    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

    // オフスクリーンキャンバスが有効な場合、そこに描画
    const targetCtx = this.settings.useOffscreenCanvas
      ? this.offscreenCtx
      : this.ctx;

    if (this.settings.useOffscreenCanvas) {
      targetCtx.clearRect(
        0,
        0,
        this.offscreenCanvas.width,
        this.offscreenCanvas.height
      );
    }

    // 1. 背景レイヤー描画
    if (this.settings.enableBackgroundLayer) {
      this._renderBackgroundLayer(targetCtx, timestamp);
    }

    // 2. お題テキストレイヤー描画
    this._renderProblemLayer(targetCtx, timestamp);

    // 3. キーボードレイヤー描画
    if (this.settings.enableKeyboardLayer) {
      this._renderKeyboardLayer(targetCtx, timestamp);
    }

    // オフスクリーンキャンバスを本物のキャンバスにコピー
    if (this.settings.useOffscreenCanvas) {
      this.ctx.drawImage(this.offscreenCanvas, 0, 0);
    }
  }

  /**
   * 背景レイヤーの描画
   * @param {CanvasRenderingContext2D} ctx 描画コンテキスト
   * @param {number} timestamp タイムスタンプ
   */
  _renderBackgroundLayer(ctx, timestamp) {
    // 静的背景が既に描画されていて変更がない場合はキャッシュを使用
    if (this._staticContentRendered && this.staticBackgroundCanvas) {
      ctx.drawImage(this.staticBackgroundCanvas, 0, 0);
      return;
    }

    // 背景グラデーション
    const width = this.canvas.width;
    const height = this.canvas.height;
    const targetCtx = this.staticBackgroundCtx || ctx;

    const gradient = targetCtx.createLinearGradient(0, 0, 0, height);
    gradient.addColorStop(0, '#0f1218');
    gradient.addColorStop(1, '#161b24');

    targetCtx.fillStyle = gradient;
    targetCtx.fillRect(0, 0, width, height);

    // グリッド線（軽量化）
    targetCtx.strokeStyle = 'rgba(65, 105, 225, 0.1)';
    targetCtx.lineWidth = 1;

    // 水平グリッド線（50px間隔）
    const gridSpacing = 50;
    for (let y = gridSpacing; y < height; y += gridSpacing) {
      targetCtx.beginPath();
      targetCtx.moveTo(0, y);
      targetCtx.lineTo(width, y);
      targetCtx.stroke();
    }

    // 静的コンテンツとしてマーク
    this._staticContentRendered = true;

    // 静的キャンバスを使用しない場合は、コンテキストに直接描画済み
    if (!this.staticBackgroundCtx) {
      return;
    }

    // 静的キャンバスの内容をターゲットに転送
    ctx.drawImage(this.staticBackgroundCanvas, 0, 0);
  }

  /**
   * お題テキストレイヤーの描画
   * @param {CanvasRenderingContext2D} ctx 描画コンテキスト
   * @param {number} timestamp タイムスタンプ
   */
  _renderProblemLayer(ctx, timestamp) {
    // 状態がない場合は何もしない
    if (!this.gameState) return;

    const { romaji = '', typedLength = 0 } = this.gameState;

    // お題がない場合は何もしない
    if (!romaji) return;

    const width = ctx.canvas.width;
    const height = ctx.canvas.height;
    const fontSize = this.settings.fontSize;

    // フォント設定
    ctx.font = `${fontSize}px ${this.settings.fontFamily}`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';

    // 文字を描画する位置 (中央配置)
    const centerX = width / 2;
    const centerY = height * 0.4; // 画面の上部40%位置

    // 1. 全体を通常色で描画
    ctx.fillStyle = this.settings.textColor;
    ctx.fillText(romaji, centerX, centerY);

    // 2. 入力済みの部分を上書き
    if (typedLength > 0) {
      const typedText = romaji.substring(0, typedLength);
      ctx.fillStyle = this.settings.typedColor;
      ctx.fillText(typedText, centerX, centerY);
    }

    // 3. 次の文字をハイライト
    if (typedLength < romaji.length) {
      const nextChar = romaji[typedLength];
      const measuredText = ctx.measureText(romaji.substring(0, typedLength));
      const nextCharX =
        centerX - ctx.measureText(romaji).width / 2 + measuredText.width;

      ctx.fillStyle = this.settings.highlightColor;
      ctx.fillText(
        nextChar,
        nextCharX + ctx.measureText(nextChar).width / 2,
        centerY
      );
    }
  }

  /**
   * キーボードレイヤーの描画
   * @param {CanvasRenderingContext2D} ctx 描画コンテキスト
   * @param {number} timestamp タイムスタンプ
   */
  _renderKeyboardLayer(ctx, timestamp) {
    // キーボードの基本配置を静的に描画
    if (!this._staticContentRendered && this.staticKeyboardCtx) {
      this._renderStaticKeyboard(this.staticKeyboardCtx);
    }

    // 静的キーボードを使用
    if (this.staticKeyboardCanvas) {
      ctx.drawImage(
        this.staticKeyboardCanvas,
        0,
        this.canvas.height - this.staticKeyboardCanvas.height
      );
    }

    // 動的部分（現在のキーハイライトなど）を描画
    this._renderKeyHighlights(ctx);
  }

  /**
   * 静的なキーボード基本レイアウトの描画
   * @param {CanvasRenderingContext2D} ctx 描画コンテキスト
   */
  _renderStaticKeyboard(ctx) {
    // キーボードの基本レイアウトを描画（キーの位置と通常状態）
    const width = ctx.canvas.width;
    const height = ctx.canvas.height;

    // キーボードの背景
    ctx.fillStyle = 'rgba(20, 20, 30, 0.7)';
    ctx.fillRect(0, 0, width, height);

    // キーの配置
    const keyRows = [
      ['1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '-', '='],
      ['Q', 'W', 'E', 'R', 'T', 'Y', 'U', 'I', 'O', 'P', '[', ']'],
      ['A', 'S', 'D', 'F', 'G', 'H', 'J', 'K', 'L', ';', "'", '\\'],
      ['Z', 'X', 'C', 'V', 'B', 'N', 'M', ',', '.', '/'],
    ];

    const keySize = Math.min(width / 14, height / 5);
    const startY = height * 0.1;
    const startX = (width - keyRows[0].length * keySize * 1.1) / 2;

    // 各行のキーを描画
    keyRows.forEach((row, rowIndex) => {
      const rowOffset = rowIndex * 0.2 * keySize; // 各行の水平オフセット
      row.forEach((key, keyIndex) => {
        const x = startX + rowOffset + keyIndex * keySize * 1.1;
        const y = startY + rowIndex * keySize * 1.1;

        // キーの背景
        ctx.fillStyle = 'rgba(40, 40, 50, 0.9)';
        ctx.fillRect(x, y, keySize, keySize);

        // キーの境界
        ctx.strokeStyle = 'rgba(100, 100, 120, 0.6)';
        ctx.lineWidth = 1;
        ctx.strokeRect(x, y, keySize, keySize);

        // キー文字
        ctx.fillStyle = '#ffffff';
        ctx.font = `${keySize * 0.5}px ${this.settings.fontFamily}`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(key, x + keySize / 2, y + keySize / 2);
      });
    });

    // スペースキー
    const spaceWidth = width * 0.4;
    const spaceX = (width - spaceWidth) / 2;
    const spaceY = startY + 4 * keySize * 1.1;

    ctx.fillStyle = 'rgba(40, 40, 50, 0.9)';
    ctx.fillRect(spaceX, spaceY, spaceWidth, keySize);

    ctx.strokeStyle = 'rgba(100, 100, 120, 0.6)';
    ctx.strokeRect(spaceX, spaceY, spaceWidth, keySize);
  }

  /**
   * キーハイライトの描画（動的部分）
   * @param {CanvasRenderingContext2D} ctx 描画コンテキスト
   */
  _renderKeyHighlights(ctx) {
    if (!this.gameState || !this.gameState.nextKey) return;

    const nextKey = this.gameState.nextKey.toUpperCase();
    const lastKey = this.gameState.lastPressedKey?.toUpperCase();

    // キーボードのレイアウト情報を取得
    const width = ctx.canvas.width;
    const height = ctx.canvas.height;
    const keySize = Math.min(width / 14, height / 5);
    const startY = height - this.staticKeyboardCanvas.height + height * 0.1;
    const startX = (width - 12 * keySize * 1.1) / 2;

    // キーの配置マップを作成
    const keyLayout = this._createKeyboardLayout(startX, startY, keySize);

    // 次のキーをハイライト
    if (nextKey && keyLayout[nextKey]) {
      const { x, y } = keyLayout[nextKey];

      // 次のキーを強調
      ctx.fillStyle = 'rgba(255, 180, 30, 0.7)'; // オレンジ色で強調
      ctx.fillRect(x, y, keySize, keySize);

      // キーの境界線
      ctx.strokeStyle = 'rgba(255, 200, 0, 0.9)';
      ctx.lineWidth = 2;
      ctx.strokeRect(x, y, keySize, keySize);

      // キー文字
      ctx.fillStyle = '#ffffff';
      ctx.font = `${keySize * 0.5}px ${this.settings.fontFamily}`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(nextKey, x + keySize / 2, y + keySize / 2);
    }

    // 最後に押されたキーをアニメーション
    if (lastKey && keyLayout[lastKey] && lastKey !== nextKey) {
      const { x, y } = keyLayout[lastKey];

      // キーの押下エフェクト
      ctx.fillStyle = 'rgba(60, 220, 130, 0.7)'; // 緑色のエフェクト
      ctx.fillRect(x, y, keySize, keySize);

      // キーの境界線
      ctx.strokeStyle = 'rgba(80, 240, 160, 0.9)';
      ctx.lineWidth = 1;
      ctx.strokeRect(x, y, keySize, keySize);

      // キー文字
      ctx.fillStyle = '#ffffff';
      ctx.font = `${keySize * 0.5}px ${this.settings.fontFamily}`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(lastKey, x + keySize / 2, y + keySize / 2);
    }
  }

  /**
   * キーボードレイアウトを生成
   * @param {number} startX 開始X座標
   * @param {number} startY 開始Y座標
   * @param {number} keySize キーサイズ
   * @returns {Object} キーの位置マップ
   * @private
   */
  _createKeyboardLayout(startX, startY, keySize) {
    const layout = {};
    const keyRows = [
      ['1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '-', '='],
      ['Q', 'W', 'E', 'R', 'T', 'Y', 'U', 'I', 'O', 'P', '[', ']'],
      ['A', 'S', 'D', 'F', 'G', 'H', 'J', 'K', 'L', ';', "'", '\\'],
      ['Z', 'X', 'C', 'V', 'B', 'N', 'M', ',', '.', '/'],
    ];

    keyRows.forEach((row, rowIndex) => {
      const rowOffset = rowIndex * 0.2 * keySize; // 各行のオフセット
      row.forEach((key, keyIndex) => {
        layout[key] = {
          x: startX + rowOffset + keyIndex * keySize * 1.1,
          y: startY + rowIndex * keySize * 1.1,
        };
      });
    });

    // スペースキー
    layout[' '] = {
      x: (this.canvas.width - this.canvas.width * 0.4) / 2,
      y: startY + 4 * keySize * 1.1,
    };

    return layout;
  }

  /**
   * タイピングテキスト（ローマ字）の描画
   * @param {CanvasRenderingContext2D} ctx 描画コンテキスト
   * @private
   */
  _renderTypingText(ctx) {
    if (!this.gameState) return;

    // 新しいdrawPromptメソッドを利用して描画
    this.drawPrompt(ctx, this.gameState);
  }

  /**
   * タイピングテキスト（ローマ字）の描画関数 - 改良版
   * 状態ベースでテキストの各文字をレンダリング
   * - 入力済み文字は緑色で表示
   * - 部分入力中の文字（「と」の「t」など）も緑色で表示
   * - 次に入力すべき文字はオレンジ色（部分入力中はエラー時でも赤くしない）
   * - 残りの文字は白色で表示
   *
   * @param {CanvasRenderingContext2D} ctx 描画コンテキスト
   * @param {Object} state ゲーム状態
   * @private
   */
  drawPrompt(ctx, state) {
    if (!state || !state.romaji) return;

    const {
      romaji = '',
      typedLength = 0,
      currentInput = '', // 部分入力（例：「と」の「t」）を取得
      isError = false,
      startY = 160, // 垂直位置（オプション）
      displayParts = null, // InputProcessorから提供されるパーツ情報（オプション）
    } = state;

    // フォント設定
    ctx.font = `${this.settings.fontSize}px ${this.settings.fontFamily}`;
    ctx.textAlign = 'left';
    ctx.textBaseline = 'middle';

    // 文字幅を計算（モノスペースフォント前提）
    const charWidth = this.settings.fontSize * 0.6;

    // タイピングテキスト表示位置
    const textWidth = romaji.length * charWidth;
    const startX = (this.settings.width - textWidth) / 2;

    // InputProcessorから提供されるパーツ情報がある場合、それを使用
    if (displayParts && Array.isArray(displayParts)) {
      let xPos = startX;

      // 各パーツに対する処理
      displayParts.forEach((part) => {
        const { type, text } = part;

        // パーツの種類に応じた色設定
        switch (type) {
          case 'typed':
            ctx.fillStyle = this.settings.typedColor; // 入力済み
            break;
          case 'current_input':
            ctx.fillStyle = this.settings.typedColor; // 部分入力
            break;
          case 'next_char':
            ctx.fillStyle = this.settings.highlightColor; // 次の文字
            break;
          case 'error':
            ctx.fillStyle = this.settings.errorColor; // エラー
            break;
          case 'current_remaining':
            ctx.fillStyle = this.settings.highlightColor; // 部分入力の残り
            break;
          case 'not_typed':
            ctx.fillStyle = this.settings.textColor; // 未入力
            break;
          default:
            ctx.fillStyle = this.settings.textColor;
        }

        // テキスト描画
        if (text) {
          for (let i = 0; i < text.length; i++) {
            ctx.fillText(text[i], xPos, startY);
            xPos += charWidth;
          }
        }
      });

      // 入力完了チェック
      if (romaji.length > 0 && typedLength >= romaji.length) {
        ctx.fillStyle = this.settings.typedColor;
        ctx.fillText('✓', xPos, startY);
      }

      return;
    }

    // 従来の方式でのレンダリング（互換性のため）
    // 部分入力が存在する場合は、入力済み文字数 + 部分入力の次の位置
    // 部分入力がない場合は、入力済み文字数の位置
    const nextCharPosition = currentInput ? typedLength + 1 : typedLength;

    // すべての文字を一文字ずつ処理
    for (let i = 0; i < romaji.length; i++) {
      const char = romaji[i];

      // 文字の状態に基づいて色を決定
      if (i < typedLength) {
        // すでに入力済みの文字
        ctx.fillStyle = this.settings.typedColor; // 緑色
      } else if (i === typedLength && currentInput) {
        // 部分入力の文字（例：「と」の「t」）
        ctx.fillStyle = this.settings.typedColor; // 緑色
      } else if (i === nextCharPosition) {
        // 次に入力すべき文字
        // 部分入力がある場合は常にオレンジ色を使用（エラー時でも赤くしない）
        if (currentInput) {
          ctx.fillStyle = this.settings.highlightColor; // 部分入力中は常にオレンジ色
        } else {
          // 部分入力がない場合のみ、エラー時は赤色を使用
          ctx.fillStyle =
            isError === true
              ? this.settings.errorColor // エラー時は赤色
              : this.settings.highlightColor; // 通常はオレンジ色
        }
      } else {
        // まだ入力されていない文字
        ctx.fillStyle = this.settings.textColor; // 白色
      }

      // 文字を描画
      ctx.fillText(char, startX + i * charWidth, startY);
    }

    if (romaji.length > 0 && typedLength >= romaji.length) {
      // 入力完了時のチェックマーク
      ctx.fillStyle = this.settings.typedColor; // 緑色（完了）
      ctx.fillText('✓', startX + romaji.length * charWidth, startY);
    }
  }

  /**
   * 仮想キーボードの描画
   * @param {CanvasRenderingContext2D} ctx 描画コンテキスト
   * @private
   */
  _renderKeyboard(ctx) {
    if (!this.gameState) return;

    const { nextKey = '', lastPressedKey = '' } = this.gameState;

    // キーボード定数
    const KEY_SIZE = 36;
    const KEY_MARGIN = 4;
    const KEY_RADIUS = 4;
    const KEYBOARD_Y = this.settings.height - 240;

    // キーボードレイアウト（日本語）
    const KEYBOARD_LAYOUT = [
      ['1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '-', '^', '\\'],
      ['q', 'w', 'e', 'r', 't', 'y', 'u', 'i', 'o', 'p', '@', '['],
      ['a', 's', 'd', 'f', 'g', 'h', 'j', 'k', 'l', ';', ':', ']'],
      ['z', 'x', 'c', 'v', 'b', 'n', 'm', ',', '.', '/', '\\'],
      [' '], // スペースキー
    ];

    // キーボード描画位置
    let startY = KEYBOARD_Y;

    // 各行の描画
    KEYBOARD_LAYOUT.forEach((row, rowIndex) => {
      // この行の開始X位置を計算（中央揃え）
      const rowWidth = row.length * (KEY_SIZE + KEY_MARGIN) - KEY_MARGIN;
      const rowStartX = (this.settings.width - rowWidth) / 2;
      row.forEach((key, keyIndex) => {
        let keyWidth = key === ' ' ? KEY_SIZE * 6 : KEY_SIZE;
        const keyX = rowStartX + keyIndex * (KEY_SIZE + KEY_MARGIN);
        const keyY = startY; // キーの背景
        ctx.fillStyle = '#333';
        if (key === nextKey) {
          // 次に入力すべきキー - 明るいオレンジに変更
          ctx.fillStyle = '#FFB41E';
        }
        // 最後に押したキーの緑表示は無効化（仕様変更）

        // 角丸長方形を描画
        this._roundRect(ctx, keyX, keyY, keyWidth, KEY_SIZE, KEY_RADIUS);

        // キーの文字
        ctx.fillStyle = '#fff';
        ctx.font = '16px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(
          key === ' ' ? 'SPACE' : key,
          keyX + keyWidth / 2,
          keyY + KEY_SIZE / 2
        );
      });

      startY += KEY_SIZE + KEY_MARGIN;
    });
  }

  /**
   * 角丸長方形の描画（ユーティリティ）
   * @param {CanvasRenderingContext2D} ctx 描画コンテキスト
   * @param {number} x X座標
   * @param {number} y Y座標
   * @param {number} width 幅
   * @param {number} height 高さ
   * @param {number} radius 角の半径
   * @private
   */
  _roundRect(ctx, x, y, width, height, radius) {
    ctx.beginPath();
    ctx.moveTo(x + radius, y);
    ctx.lineTo(x + width - radius, y);
    ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
    ctx.lineTo(x + width, y + height - radius);
    ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
    ctx.lineTo(x + radius, y + height);
    ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
    ctx.lineTo(x, y + radius);
    ctx.quadraticCurveTo(x, y, x + radius, y);
    ctx.closePath();
    ctx.fill();
  }

  /**
   * キャンバスサイズを設定する - CanvasManagerとの互換用
   * @param {number} width - 新しい幅
   * @param {number} height - 新しい高さ
   */
  setCanvasSize(width, height) {
    if (!this.canvas) return this;

    // 設定を更新
    this.settings.width = width;
    this.settings.height = height;

    // キャンバス内部バッファサイズを更新（devicePixelRatioを使わない）
    this.canvas.width = width;
    this.canvas.height = height;

    // コンテキストをリセット
    this.ctx.setTransform(1, 0, 0, 1, 0, 0);

    // デフォルト描画スタイルを再設定
    this.ctx.textBaseline = 'middle';
    this.ctx.textAlign = 'left';
    this.ctx.imageSmoothingEnabled = false;

    // オフスクリーンキャンバスがあれば更新
    if (this.settings.useOffscreenCanvas && this.offscreenCanvas) {
      this.offscreenCanvas.width = width;
      this.offscreenCanvas.height = height;
      this.offscreenCtx.setTransform(1, 0, 0, 1, 0, 0);
      this.offscreenCtx.textBaseline = 'middle';
      this.offscreenCtx.textAlign = 'left';
      this.offscreenCtx.imageSmoothingEnabled = false;
    }

    // 再描画フラグを設定
    this._needsRender = true;

    return this;
  }

  /**
   * リソース解放
   */
  destroy() {
    // アニメーションを停止
    this.stopAnimation();

    // キャンバスの参照を解放
    this.canvas = null;
    this.ctx = null;

    // オフスクリーンキャンバスの参照を解放
    this.offscreenCanvas = null;
    this.offscreenCtx = null;
    this.staticBackgroundCanvas = null;
    this.staticBackgroundCtx = null;
    this.staticKeyboardCanvas = null;
    this.staticKeyboardCtx = null;

    // ゲーム状態の参照を解放
    this.gameState = null;

    return this;
  }

  /**
   * プリレンダリングする文字セットを生成
   * パフォーマンス向上のために、よく使用される文字を事前にレンダリングする
   * @private
   */
  _preRenderCharSet() {
    if (!this.ctx) return;

    // 事前レンダリングする文字セット
    const chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789.,;:?!-_\'"/\\@#$%^&*()[]{}+=<>';
    
    // オフスクリーンキャンバスを作成
    const charCanvas = document.createElement('canvas');
    const fontSize = this.settings.fontSize;
    const charSize = fontSize * 1.5; // 余白のため少し大きめに
    charCanvas.width = charSize;
    charCanvas.height = charSize;
    const charCtx = charCanvas.getContext('2d');
    
    // 各文字をレンダリングしてキャッシュに保存
    chars.split('').forEach(char => {
      // キャンバスをクリア
      charCtx.clearRect(0, 0, charSize, charSize);
      
      // 文字の描画スタイル
      charCtx.font = `${fontSize}px ${this.settings.fontFamily}`;
      charCtx.textAlign = 'center';
      charCtx.textBaseline = 'middle';
      
      // 通常の文字
      charCtx.fillStyle = this.settings.textColor;
      charCtx.fillText(char, charSize / 2, charSize / 2);
      this.charCache.set(`normal_${char}`, charCtx.getImageData(0, 0, charSize, charSize));
      
      // タイプ済みの文字
      charCtx.clearRect(0, 0, charSize, charSize);
      charCtx.fillStyle = this.settings.typedColor;
      charCtx.fillText(char, charSize / 2, charSize / 2);
      this.charCache.set(`typed_${char}`, charCtx.getImageData(0, 0, charSize, charSize));
      
      // ハイライト文字
      charCtx.clearRect(0, 0, charSize, charSize);
      charCtx.fillStyle = this.settings.highlightColor;
      charCtx.fillText(char, charSize / 2, charSize / 2);
      this.charCache.set(`highlight_${char}`, charCtx.getImageData(0, 0, charSize, charSize));
      
      // エラー文字
      charCtx.clearRect(0, 0, charSize, charSize);
      charCtx.fillStyle = this.settings.errorColor;
      charCtx.fillText(char, charSize / 2, charSize / 2);
      this.charCache.set(`error_${char}`, charCtx.getImageData(0, 0, charSize, charSize));
    });
  }
}
