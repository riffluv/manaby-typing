'use client';

/**
 * GameController.js
 * 繧ｲ繝ｼ繝繧ｳ繝ｳ繝医Ο繝ｼ繝ｩ繝ｼ繝輔ャ繧ｯ
 * 雋ｬ莉ｻ: 繧ｲ繝ｼ繝繝ｭ繧ｸ繝・け縺ｨUI騾｣謳ｺ
 */

import { useState, useEffect, useCallback, useRef } from 'react';
import { useGameContext, SCREENS } from '../../contexts/GameContext';
import { useTypingGame } from '../../hooks/useTypingGame';
import soundSystem from '../../utils/SoundUtils';
import { getRandomProblem } from '../../utils/ProblemSelector';
import TypingUtils from '../../utils/TypingUtils'; // KPM險育ｮ礼畑縺ｫTypingUtils繧偵う繝ｳ繝昴・繝・
import typingWorkerManager from '../../utils/TypingWorkerManager'; // Worker邂｡逅・・縺溘ａ縺ｮ繧､繝ｳ繝昴・繝医ｒ霑ｽ蜉

/**
 * 繧ｲ繝ｼ繝繧ｳ繝ｳ繝医Ο繝ｼ繝ｩ繝ｼ繝輔ャ繧ｯ
 * @param {Object} options 險ｭ螳壹が繝励す繝ｧ繝ｳ
 * @returns {Object} 繧ｲ繝ｼ繝繧ｳ繝ｳ繝医Ο繝ｼ繝ｩ繝ｼ縺ｮAPI縺ｨ迥ｶ諷・
 */
export function useGameController(options = {}) {
  const {
    onDebugInfoUpdate = null,
    onLastPressedKeyChange = null,
    goToScreen,
  } = options;

  // Game Context縺九ｉ迥ｶ諷句叙蠕・
  const { gameState } = useGameContext();

  // 蝠城｡檎憾諷・
  const [currentProblem, setCurrentProblem] = useState(null);

  // 蜑榊屓縺ｮ繧ｲ繝ｼ繝迥ｶ諷九ｒ菫晏ｭ・
  const prevGameStateRef = useRef({
    solvedCount: 0,
    requiredProblemCount: 0,
  });
  // 繝代ヵ繧ｩ繝ｼ繝槭Φ繧ｹ貂ｬ螳・
  const performanceRef = useRef({
    lastKeyPressTime: 0,
    inputLatency: 0,
  });

  // 繧ｿ繧､繝斐Φ繧ｰ蜿ら・・亥ｾｪ迺ｰ蜿ら・蝠城｡後ｒ蝗樣∩・・
  const typingRef = useRef(null);

  // Game Context縺九ｉ迥ｶ諷区峩譁ｰ髢｢謨ｰ繧貞叙蠕・
  const { setGameState } = useGameContext();  /**
   * 蝠城｡後′螳御ｺ・＠縺滓凾縺ｮ蜃ｦ逅・
   */  const handleProblemComplete = useCallback((typingStats) => {
    // 蜉ｹ譫憺浹蜀咲函縺ｯ逵∫払・育ｶｴ繧ｰ繝ｫ繝域浹螢ｰ縺ｨ縺九・繧九◆繧・
    
    // 谺｡縺ｮ蝠城｡梧焚繧定ｨ育ｮ・
    const newSolvedCount = gameState.solvedCount + 1;
    console.log('[GameController] 蝠城｡悟ｮ御ｺ・- 隗｣遲疲焚譖ｴ譁ｰ:', newSolvedCount);

    // 繧ｲ繝ｼ繝繧ｯ繝ｪ繧｢蛻､螳・
    const isGameClear = newSolvedCount >= gameState.requiredProblemCount;

    // 縺吶∋縺ｦ縺ｮ繧ｹ繧ｳ繧｢險育ｮ励・蜑企勁 - 繝ｪ繝輔ぃ繧ｯ繧ｿ繝ｪ繝ｳ繧ｰ縺ｮ縺溘ａ縺ｮ貅門ｙ

    console.log('[GameController] 繧ｹ繧ｳ繧｢險育ｮ励・蜑企勁縺輔ｌ縺ｾ縺励◆'); if (isGameClear) {
      // 繧ｲ繝ｼ繝繧ｯ繝ｪ繧｢譎ゅ・蜃ｦ逅・
      console.log('[GameController] 蜈ｨ蝠城｡悟ｮ御ｺ・- 繝ｪ繧ｶ繝ｫ繝育判髱｢縺ｫ驕ｷ遘ｻ縺励∪縺・);

      // 邨ゆｺ・凾髢薙ｒ險倬鹸
      const endTime = Date.now();
      const startTime = gameState.startTime || typing.typingStats?.statsRef?.current?.startTime || endTime;
      const elapsedTimeMs = endTime - startTime;

      // KPM險育ｮ・- 蝠城｡後＃縺ｨ縺ｮKPM縺ｮ蟷ｳ蝮・､繧貞━蜈・
      let averageKPM = 0;
      // 蜷・撫鬘後・KPM繧堤ｴｯ遨・
      const allProblemKPMs = [
        ...(gameState.problemKPMs || []),
        typing?.typingStats?.displayStats?.kpm || 0
      ].filter(kpm => kpm > 0);

      if (allProblemKPMs && allProblemKPMs.length > 0) {
        // 蝠城｡後＃縺ｨ縺ｮKPM縺ｮ蟷ｳ蝮・ｒ險育ｮ・
        averageKPM = allProblemKPMs.reduce((sum, kpm) => sum + kpm, 0) / allProblemKPMs.length;
      } else {
        // 蝠城｡後ョ繝ｼ繧ｿ縺後↑縺・ｴ蜷医・蜊倡ｴ碑ｨ育ｮ・
        const totalCorrectKeyCount = typing?.typingStats?.statsRef?.current?.correctKeyCount || 0;
        averageKPM = Math.floor(totalCorrectKeyCount / (elapsedTimeMs / 60000));
      }      // 繧ｲ繝ｼ繝蜈ｨ菴薙・邏ｯ遨阪く繝ｼ蜈･蜉帷ｵｱ險医・險育ｮ・
      // 譛蠕後・縺企｡後・繧ｭ繝ｼ蜈･蜉帷憾豕・
      const lastProblemCorrectKeys = typing?.typingStats?.statsRef?.current?.correctKeyCount || 0;
      const lastProblemMissKeys = typing?.typingStats?.statsRef?.current?.mistakeCount || 0;

      // 邏ｯ遨榊・蜉帶焚縺ｮ險育ｮ暦ｼ亥・蝠城｡後・邏ｯ遨搾ｼ・
      const totalCorrectKeyCount = (gameState.totalCorrectKeys || 0) + lastProblemCorrectKeys;
      const totalMissCount = (gameState.totalMissKeys || 0) + lastProblemMissKeys;
      const totalKeystrokes = totalCorrectKeyCount + totalMissCount;
      const accuracy = totalKeystrokes > 0 ? Math.round((totalCorrectKeyCount / totalKeystrokes) * 100) : 100;

      // 蝠城｡梧焚縺ｯ縲瑚ｧ｣縺・◆蝠城｡梧焚縲阪ｒ陦ｨ遉ｺ
      const correctProblemCount = newSolvedCount;

      // 繧医ｊ隧ｳ邏ｰ縺ｪ繝・ヰ繝・げ繝ｭ繧ｰ
      console.log('[GameController] 邨ｱ險域ュ蝣ｱ縺ｮ隧ｳ邏ｰ:', {
        邏ｯ遨阪く繝ｼ豁｣隗｣謨ｰ: totalCorrectKeyCount,
        邏ｯ遨阪く繝ｼ繝溘せ謨ｰ: totalMissCount,
        譛蠕後・蝠城｡後く繝ｼ豁｣隗｣謨ｰ: lastProblemCorrectKeys,
        譛蠕後・蝠城｡後く繝ｼ繝溘せ謨ｰ: lastProblemMissKeys,
        蝠城｡梧ｭ｣隗｣謨ｰ: correctProblemCount,
        邏ｯ遨肴遠骰ｵ邱乗焚: totalKeystrokes,
        豁｣遒ｺ邇・ accuracy,
        KPM: averageKPM,
        蝠城｡悟挨KPM: allProblemKPMs
      });      // 繧ｹ繧ｳ繧｢繝・・繧ｿ繧竪ameContext縺ｫ菫晏ｭ・
      setGameState(prev => ({
        ...prev,
        solvedCount: newSolvedCount,
        isGameClear: true,
        problemKPMs: allProblemKPMs,
        startTime: startTime,
        endTime: endTime,
        // 蜈ｨ蝠城｡後・邏ｯ遨咲ｵｱ險医ｒ菫晏ｭ・
        totalCorrectKeys: totalCorrectKeyCount,
        totalMissKeys: totalMissCount,
        // 繝ｪ繧ｶ繝ｫ繝育判髱｢縺ｧ菴ｿ逕ｨ縺吶ｋ邨ｱ險域ュ蝣ｱ・亥ｾ捺擂繝｢繝ｼ繝峨→蜷後§蠖｢蠑上〒謠蝉ｾ幢ｼ・
        stats: {
          kpm: Math.round(averageKPM * 10) / 10, // 蟆乗焚轤ｹ1菴阪∪縺ｧ縺ｮ蟷ｳ蝮⑫PM
          correctCount: totalCorrectKeyCount, // 邏ｯ遨阪・豁｣隗｣繧ｭ繝ｼ謨ｰ
          missCount: totalMissCount, // 邏ｯ遨阪・繝溘せ蜈･蜉帶焚
          accuracy: accuracy, // 豁｣遒ｺ邇・ｼ育ｴｯ遨榊､縺九ｉ險育ｮ暦ｼ・
          rank: TypingUtils.getRank(averageKPM) || 'F',
          problemKPMs: allProblemKPMs,
          elapsedTimeMs: elapsedTimeMs,
          totalTime: elapsedTimeMs / 1000,
          solvedProblems: correctProblemCount // 蛻･騾斐∬ｧ｣縺・◆蝠城｡梧焚繧りｿｽ蜉
        }
      }));

      // 繝ｪ繧ｶ繝ｫ繝育判髱｢縺ｫ驕ｷ遘ｻ
      window.lastResultTransition = Date.now();

      setTimeout(() => {
        console.log('[GameController] handleProblemComplete: 繝ｪ繧ｶ繝ｫ繝育判髱｢縺ｫ驕ｷ遘ｻ - 繧ｹ繧ｳ繧｢縺ｪ縺・);
        goToScreen(SCREENS.RESULT, {
          playSound: true,
          soundType: 'result',
          // 繧ｹ繧ｳ繧｢諠・ｱ縺ｯ繝ｪ繧ｶ繝ｫ繝育判髱｢縺ｫ貂｡縺輔↑縺・
          gameState: {}
        });
      }, 300);
    } else {
      // 繧ｲ繝ｼ繝繧ｯ繝ｪ繧｢縺ｧ縺ｪ縺・ｴ蜷・- 谺｡縺ｮ蝠城｡後↓騾ｲ繧蜃ｦ逅・     // 蝠城｡梧焚縺ｨ邨ｱ險域ュ蝣ｱ繧呈峩譁ｰ
      const currentProblemKPM = typing?.typingStats?.displayStats?.kpm || 0;
      const currentProblemCorrectKeys = typing?.typingStats?.statsRef?.current?.correctKeyCount || 0;
      const currentProblemMistakes = typing?.typingStats?.statsRef?.current?.mistakeCount || 0;

      console.log('[GameController] 蝠城｡悟ｮ御ｺ・ｵｱ險・ ', {
        KPM: currentProblemKPM,
        豁｣隗｣繧ｭ繝ｼ謨ｰ: currentProblemCorrectKeys,
        繝溘せ謨ｰ: currentProblemMistakes
      });

      // 蝠城｡後＃縺ｨ縺ｮKPM諠・ｱ繧定塘遨・
      const updatedProblemKPMs = [
        ...(gameState.problemKPMs || []),
        currentProblemKPM
      ].filter(kpm => kpm > 0);

      // 蜈ｨ蝠城｡後・邏ｯ遨咲ｵｱ險医ｒ譖ｴ譁ｰ
      setGameState(prev => ({
        ...prev,
        solvedCount: newSolvedCount,
        problemKPMs: updatedProblemKPMs,
        // 邏ｯ遨肴遠骰ｵ謨ｰ繧りｿｽ霍｡
        totalCorrectKeys: (prev.totalCorrectKeys || 0) + currentProblemCorrectKeys,
        totalMissKeys: (prev.totalMissKeys || 0) + currentProblemMistakes
      }));      // 谺｡縺ｮ蝠城｡後ｒ繧ｻ繝・ヨ・域怙蟆城剞縺ｮ繝・ぅ繝ｬ繧､縺ｧ邏譌ｩ縺剰｡ｨ遉ｺ・・
      setTimeout(() => {
        // 髮｣譏灘ｺｦ險ｭ螳壹・遒ｺ隱阪Ο繧ｰ
        console.log('[GameController] 谺｡縺ｮ蝠城｡碁∈謚・- 髮｣譏灘ｺｦ險ｭ螳・', {
          difficulty: gameState.difficulty,
          category: gameState.category
        });
        
        // 譁ｰ縺励＞蝠城｡後ｒ蜿門ｾ・
        const nextProblem = getRandomProblem({
          difficulty: gameState.difficulty,
          category: gameState.category,
          excludeRecent: [currentProblem?.displayText],
        });

        // 驕ｸ謚槭＆繧後◆蝠城｡後・隧ｳ邏ｰ繧偵Ο繧ｰ
        console.log('[GameController] 谺｡縺ｮ蝠城｡後ｒ驕ｸ謚・', {
          displayText: nextProblem?.displayText,
          kanaText: nextProblem?.kanaText,
          驕ｸ謚槭＆繧後◆髮｣譏灘ｺｦ: gameState.difficulty
        });

        // 蝠城｡後ｒ繧ｻ繝・ヨ
        setCurrentProblem(nextProblem);
        
        // 繧ｿ繧､繝斐Φ繧ｰ繧ｪ繝悶ず繧ｧ繧ｯ繝医′蟄伜惠縺励《etProblem繝｡繧ｽ繝・ラ縺後≠繧句ｴ蜷医・蝠城｡後ｒ險ｭ螳・
        if (typing && typing.setProblem) {
          console.log('[GameController] 谺｡縺ｮ蝠城｡後ｒ繧ｿ繧､繝斐Φ繧ｰ繧ｻ繝・す繝ｧ繝ｳ縺ｫ險ｭ螳壹＠縺ｾ縺・);
          typing.setProblem(nextProblem);
        } else {
          console.warn('[GameController] 繧ｿ繧､繝斐Φ繧ｰ繧ｪ繝悶ず繧ｧ繧ｯ繝医∪縺溘・setProblem髢｢謨ｰ縺後≠繧翫∪縺帙ｓ');
        }
      }, 50); // 0.05遘偵・繧上★縺九↑繝・ぅ繝ｬ繧､・亥ｾ捺擂繝｢繝ｼ繝峨→蜷檎ｭ会ｼ・
    }
  }, [gameState, currentProblem, setGameState, goToScreen]);  /**
   * 繧ｿ繧､繝斐Φ繧ｰ繧ｲ繝ｼ繝繧ｫ繧ｹ繧ｿ繝繝輔ャ繧ｯ
   */
  const typing = useTypingGame({
    initialProblem: currentProblem,
    playSound: true,
    soundSystem,
    onProblemComplete: handleProblemComplete,
    onDebugInfoUpdate,
  });

  // 蛻晄悄蛹門ｾ後↓Ref縺ｫ菫晏ｭ・
  typingRef.current = typing;

  /**
   * 繧ｭ繝ｼ繧､繝吶Φ繝医ワ繝ｳ繝峨Λ
   */
  const handleKeyDown = useCallback((e) => {
    // Esc繧ｭ繝ｼ縺ｧ繝｡繝九Η繝ｼ縺ｫ謌ｻ繧・
    if (e.key === 'Escape') {
      goToScreen(SCREENS.MAIN_MENU, {
        playSound: true,
        soundType: 'button',
      });
      return;
    }

    // 繧ｿ繧､繝斐Φ繧ｰ繧ｻ繝・す繝ｧ繝ｳ縺後↑縺代ｌ縺ｰ菴輔ｂ縺励↑縺・
    if (!typing.typingSession) return;

    // 繝代ヵ繧ｩ繝ｼ繝槭Φ繧ｹ險域ｸｬ髢句ｧ・
    const startTime = performance.now();

    // 蜈･蜉帛・逅・
    const result = typing.handleInput(e.key);

    // 繝代ヵ繧ｩ繝ｼ繝槭Φ繧ｹ險域ｸｬ邨ゆｺ・→險倬鹸
    const endTime = performance.now();
    const processingTime = endTime - startTime;
    performanceRef.current.inputLatency = processingTime;
    performanceRef.current.lastKeyPressTime = Date.now();

    // 蜈･蜉帙＆繧後◆繧ｭ繝ｼ繧帝夂衍
    if (onLastPressedKeyChange) {
      onLastPressedKeyChange(e.key);
    }

    // 繝・ヰ繝・げ諠・ｱ縺ｮ譖ｴ譁ｰ
    if (typing.performanceMetrics) {
      typing.performanceMetrics.inputLatency = processingTime;
    }

    // 繧ｭ繝ｼ蜈･蜉帙う繝吶Φ繝医・莨晄眺繧呈ｭ｢繧√ｋ
    if (result && result.success) {
      e.preventDefault();
    }
  }, [typing, goToScreen, onLastPressedKeyChange]);

  /**
   * 谺｡縺ｫ蜈･蜉帙☆縺ｹ縺阪く繝ｼ繧貞叙蠕・
   */
  const getNextKey = useCallback(() => {
    return typing?.typingSession?.getCurrentExpectedKey() || '';
  }, [typing]);

  /**
   * 繧ｭ繝ｼ繧､繝吶Φ繝医Μ繧ｹ繝翫・縺ｮ險ｭ螳・
   */
  useEffect(() => {
    window.addEventListener('keydown', handleKeyDown);

    return () => {
      window.removeEventListener('keydown', handleKeyDown);
      
      // Worker縺ｮ邨ゆｺ・・逅・ｒ霑ｽ蜉
      // 繝｡繝・そ繝ｼ繧ｸ繝√Ε繝阪Ν縺碁哩縺倥ｉ繧後◆繧ｨ繝ｩ繝ｼ繧帝亟縺舌◆繧√√さ繝ｳ繝昴・繝阪Φ繝医・繧｢繝ｳ繝槭え繝ｳ繝域凾縺ｫ
      // 譏守､ｺ逧・↓繝ｪ繧ｽ繝ｼ繧ｹ繧定ｧ｣謾ｾ縺吶ｋ
      if (typingWorkerManager && typeof typingWorkerManager.reset === 'function') {
        console.log('[GameController] 繧ｳ繝ｳ繝昴・繝阪Φ繝医・繧｢繝ｳ繝槭え繝ｳ繝域凾縺ｫWorker繧偵Μ繧ｻ繝・ヨ縺励∪縺・);
        typingWorkerManager.reset().catch(err => {
          console.warn('[GameController] Worker邨ゆｺ・ｸｭ縺ｫ繧ｨ繝ｩ繝ｼ縺檎匱逕溘＠縺ｾ縺励◆:', err);
        });
      }
    };
  }, [handleKeyDown]);
  /**
   * 蛻晄悄蝠城｡後・繝ｭ繝ｼ繝・
   */
  useEffect(() => {
    // 蛻晏屓繝ｭ繝ｼ繝画凾縺句撫鬘後′縺ｪ縺・ｴ蜷医・譁ｰ縺励＞蝠城｡後ｒ繧ｻ繝・ヨ
    if (!currentProblem) {
      // 髮｣譏灘ｺｦ險ｭ螳壹・遒ｺ隱阪→繝・ヰ繝・げ繝ｭ繧ｰ
      console.log('[GameController] 迴ｾ蝨ｨ縺ｮ髮｣譏灘ｺｦ險ｭ螳・', {
        difficulty: gameState.difficulty,
        category: gameState.category
      });
      
      const initialProblem = getRandomProblem({
        difficulty: gameState.difficulty,
        category: gameState.category,
      });

      console.log('[GameController] 蛻晄悄蝠城｡後ｒ繝ｭ繝ｼ繝・', {
        displayText: initialProblem?.displayText,
        kanaText: initialProblem?.kanaText,
        驕ｸ謚槭＆繧後◆髮｣譏灘ｺｦ: gameState.difficulty,
        繧ｫ繝・ざ繝ｪ繝ｼ: gameState.category,
        蝠城｡後が繝悶ず繧ｧ繧ｯ繝亥・菴・ initialProblem
      });

      setCurrentProblem(initialProblem);

      // 繧ｿ繧､繝斐Φ繧ｰ繧ｲ繝ｼ繝縺ｫ蝠城｡後ｒ險ｭ螳・
      if (initialProblem && typing?.setProblem) {
        console.log('[GameController] 繧ｿ繧､繝斐Φ繧ｰ繧ｻ繝・す繝ｧ繝ｳ縺ｫ蝠城｡後ｒ險ｭ螳・);
        typing.setProblem(initialProblem);
      }
    }
  }, [gameState.difficulty, gameState.category, currentProblem, typing]);  // 霑斐☆蜑阪↓蝠城｡檎憾諷九・繝ｭ繧ｰ蜃ｺ蜉・
  console.log('[GameController] 迴ｾ蝨ｨ縺ｮ迥ｶ諷・', {
    'currentProblem': currentProblem?.displayText,
    'typing.displayInfo': typing?.displayInfo ? '縺ゅｊ' : '縺ｪ縺・,
    'typingRef縺ゅｊ?': typingRef.current ? '縺ゅｊ' : '縺ｪ縺・,
    'gameState.currentProblem': gameState.currentProblem?.displayText,
  });

  return {
    // 迥ｶ諷・
    typing,
    typingRef: typingRef,  // 菫ｮ豁｣貂医∩縺ｮRef
    currentProblem,
    gameState,
    // 迴ｾ蝨ｨ縺ｮ繧ｲ繝ｼ繝迥ｶ諷九ｒ蜷ｫ繧繧ｪ繝悶ず繧ｧ繧ｯ繝・
    gameState: { currentProblem },  // 迴ｾ蝨ｨ縺ｮ蝠城｡後ｒgameState縺ｮ荳驛ｨ縺ｨ縺励※譏守､ｺ逧・↓蜈ｱ譛・

    // 繝｡繧ｽ繝・ラ
    getNextKey,

    // 繝代ヵ繧ｩ繝ｼ繝槭Φ繧ｹ貂ｬ螳・
    performanceMetrics: {
      get inputLatency() {
        return performanceRef.current.inputLatency;
      },
      get lastKeyPressTime() {
        return performanceRef.current.lastKeyPressTime;
      }
    },
  };
}

/**
 * 繧ｲ繝ｼ繝螳御ｺ・ワ繝ｳ繝峨Λ繝ｼ繝輔ャ繧ｯ
 * 繝舌ャ繧ｯ繧｢繝・・縺ｨ縺励※縺ｮ蠖ｹ蜑ｲ繧呈球縺・ｼ井ｸｻ縺ｪ驕ｷ遘ｻ繝ｭ繧ｸ繝・け縺ｯhandleProblemComplete縺ｧ蜃ｦ逅・ｼ・
 */
export function useGameCompleteHandler(gameState, goToScreen, typingRef) {
  useEffect(() => {
    // 譏守､ｺ逧・↑繧ｲ繝ｼ繝繧ｯ繝ｪ繧｢縺ｮ蝣ｴ蜷医・縺ｿ蜃ｦ逅・
    if (gameState.isGameClear === true) {
      console.log('[GameCompleteHandler] 繧ｲ繝ｼ繝螳御ｺ・ｒ讀懷・縺励∪縺励◆ - 繧ｹ繧ｳ繧｢險育ｮ励・陦後＞縺ｾ縺帙ｓ');

      // 繧ｹ繧ｳ繧｢險育ｮ励ｒ縺吶∋縺ｦ蜑企勁

      // 繧ｹ繝繝ｼ繧ｺ縺ｪ驕ｷ遘ｻ縺ｮ縺溘ａ縺ｮ驕・ｻｶ・・00ms莉･荳雁燕縺ｫ驕ｷ遘ｻ縺励※縺・↑縺・ｴ蜷医・縺ｿ・・
      const lastTransitionTime = window.lastResultTransition || 0;
      const now = Date.now();

      if (now - lastTransitionTime > 500) {
        window.lastResultTransition = now;

        // handleProblemComplete縺ｨ縺ｮ陦晉ｪ√ｒ蝗樣∩縺吶ｋ縺溘ａ蟆代＠菴呵｣輔ｒ謖√◆縺帙ｋ
        setTimeout(() => {
          console.log('[GameCompleteHandler] 繝ｪ繧ｶ繝ｫ繝育判髱｢縺ｫ驕ｷ遘ｻ縺励∪縺・- 繧ｹ繧ｳ繧｢縺ｪ縺・);
          goToScreen(SCREENS.RESULT, {
            playSound: true,
            // 繧ｹ繧ｳ繧｢諠・ｱ縺ｯ貂｡縺輔↑縺・
            gameState: {}
          });
        }, 250);
      } else {
        console.log(`[GameCompleteHandler] ${now - lastTransitionTime}ms莉･蜀・↓驕ｷ遘ｻ縺励◆縺溘ａ縲・㍾隍・・遘ｻ繧偵せ繧ｭ繝・・縺励∪縺兪);
      }
    }
  }, [gameState, goToScreen, typingRef]);
}

/**
 * Worker繧ｯ繝ｪ繝ｼ繝ｳ繧｢繝・・
 * 繧ｳ繝ｳ繝昴・繝阪Φ繝医・繧｢繝ｳ繝槭え繝ｳ繝域凾縺ｫWorker繧帝←蛻・↓邨ゆｺ・
 */
export function cleanupTypingWorker() {
  // 繧ｿ繧､繝斐Φ繧ｰWorker縺ｮ繧ｯ繝ｪ繝ｼ繝ｳ繧｢繝・・
  typingWorkerManager.cleanup();
}

