/**
 * TypingWorkerManager.js
 * タイピング処理用WebワーカーとMCPシステムを統合的に管理するクラス
 * タイピングゲームのパフォーマンス最適化のための中枢システム
 * 2025年5月9日: タイピング即時応答のためにメインスレッド処理を追加
 * 2025年5月11日: Next.js環境のWeb Worker対応強化
 */

import mcpUtils from './MCPUtils';
import {
  processTypingInputOnMainThread,
  getColoringInfoOnMainThread,
  getNextExpectedKeyOnMainThread,
  clearMainThreadCache
} from './TypingProcessorMain';

// Worker参照をグローバルで管理（Next.jsのHMR対応）
let TypingWorkerRef = null;

// Next.jsのダイナミックインポートに対応するため、各種Worker生成方法を用意
const createWorkerStrategies = {
  // 戦略1: 通常のWorker作成（標準的なブラウザ環境用）
  standard: () => {
    try {
      return new Worker('/workers/typing-worker.js');
    } catch (e) {
      console.warn('[TypingWorkerManager] 標準Worker作成失敗:', e);
      return null;
    }
  },
  
  // 戦略2: URLベースでのWorker作成（モダンブラウザ用）
  urlBased: () => {
    try {
      const workerURL = new URL('/workers/typing-worker.js', window.location.origin);
      return new Worker(workerURL.toString());
    } catch (e) {
      console.warn('[TypingWorkerManager] URL指定Worker作成失敗:', e);
      return null;
    }
  },
  
  // 戦略3: Blobを使用したインラインWorker作成（フォールバック）
  blobBased: () => {
    try {
      // Workerコードの基本部分（最小限の機能）
      const workerCode = `
        // ログユーティリティの簡易実装
        const LOG_LEVELS = {
          DEBUG: 1, INFO: 2, WARN: 3, ERROR: 4
        };
        
        let currentLogLevel = LOG_LEVELS.INFO;
        
        // 簡易ロガー
        const logger = {
          debug: (msg) => { if (currentLogLevel <= LOG_LEVELS.DEBUG) console.debug('[TypingWorker]', msg); },
          info: (msg) => { if (currentLogLevel <= LOG_LEVELS.INFO) console.info('[TypingWorker]', msg); },
          warn: (msg) => { if (currentLogLevel <= LOG_LEVELS.WARN) console.warn('[TypingWorker]', msg); },
          error: (msg) => { if (currentLogLevel <= LOG_LEVELS.ERROR) console.error('[TypingWorker]', msg); },
        };
        
        // メイン処理
        self.onmessage = function(e) {
          const { type, data, callbackId } = e.data;
          
          try {
            // 入力処理
            if (type === 'processInput') {
              const { input, expected } = data;
              const isCorrect = input === expected;
              
              self.postMessage({
                type: 'inputProcessed',
                result: { 
                  input, expected, isCorrect,
                  coloringInfo: { 
                    correct: isCorrect ? input.length : 0,
                    incorrect: isCorrect ? 0 : input.length
                  }
                },
                callbackId
              });
            }
            
            // その他のメッセージはそのまま返す
            else {
              self.postMessage({ 
                type: 'response', 
                data: { received: true },
                callbackId
              });
            }
          } catch (err) {
            logger.error('処理エラー: ' + err.message);
            self.postMessage({
              type: 'error',
              error: err.message,
              callbackId
            });
          }
        };
        
        // 起動確認
        self.postMessage({ type: 'initialized', data: { status: 'ready', timestamp: Date.now() } });
      `;
      
      const blob = new Blob([workerCode], { type: 'application/javascript' });
      const blobURL = URL.createObjectURL(blob);
      const worker = new Worker(blobURL);
      
      // BlobURLを参照として保存（後で解放するため）
      worker.objectURL = blobURL;
      
      return worker;
    } catch (e) {
      console.warn('[TypingWorkerManager] Blob Worker作成失敗:', e);
      return null;
    }
  }
};

/**
 * WebワーカーとMCPシステムを統合的に管理するシングルトンクラス
 */
class TypingWorkerManager {  constructor() {
    // Worker参照
    this.worker = null;
    // ワーカーの初期化状態
    this.initialized = false;
    // コールバック管理
    this.callbacks = new Map();
    // 次のコールバックID
    this.nextCallbackId = 1;
    // 接続試行回数
    this.connectionAttempts = 0;
    // マイクロタスクキュー
    this.queue = [];
    // メッセージバッファ（ワーカー起動前のメッセージを保存）
    this.messageBuffer = [];
    // WebWorkerサポート状態（初期値はfalse、クライアント側で確認）
    this.isSupported = false;
    // パフォーマンスメトリクス
    this.metrics = {
      processCalls: 0,
      cacheMisses: 0,
      cacheHits: 0,
      processingTime: 0,
      lastSync: Date.now(),
      // 拡張メトリクス
      batchOperations: 0,
      totalMessagesSent: 0,
      totalMessagesReceived: 0,
      lastErrorTime: null,
      lastErrorMessage: null,
      activeCallbacks: 0,
      averageResponseTime: 0,
      lastPerformanceReport: null,
      highPriorityOperations: 0,
      // メインスレッド処理メトリクス
      mainThreadProcessCalls: 0,
      mainThreadProcessingTime: 0,
    };
    // キャッシュ - パフォーマンス向上のため
    this.cache = {
      inputResults: new Map(), // 入力結果のキャッシュ
      coloringInfo: new Map(), // 色分け情報のキャッシュ
    };

    // フォールバックモード（Workerが使えない場合）
    this.fallbackMode = false;

    // 処理モード設定
    this.processingMode = {
      typing: 'main-thread', // 'worker' または 'main-thread'
      effects: 'worker',     // 'worker' または 'main-thread' 
      statistics: 'worker'   // 'worker' または 'main-thread'
    };

    // 高速アクセス用に共有オブジェクト
    this.sharedState = {
      nextExpectedKey: '',
      inputMode: 'normal',
      lastUpdateTimestamp: 0,
    };

    // クライアントサイドのみの処理
    if (typeof window !== 'undefined') {
      // WebWorkerのサポート状態をクライアントサイドで確認
      this.isSupported = typeof Worker !== 'undefined';
      
      // グローバルアクセス用
      window.typingWorkerManager = this;
      
      // 遅延初期化（Next.jsのハイドレーションが完了するのを待つ）
      setTimeout(() => {
        this._initOnNextTick();
      }, 0);
    }
  }

  /**
   * 次のマイクロタスクでワーカーを初期化
   * プリエンプティブでない（他の処理をブロックしない）
   */
  _initOnNextTick() {
    queueMicrotask(() => {
      this._initWorker();
    });
  }
  /**
   * 内部メソッド: ワーカーの初期化
   * @private
   */  _initWorker() {
    // Next.js環境を考慮したWebWorkerサポートチェック
    if (typeof window === 'undefined') {
      console.warn(
        '[TypingWorkerManager] ブラウザ環境ではありません。フォールバックモードを使用します。'
      );
      this.fallbackMode = true;
      this.initialized = true; // サーバー側では初期化完了とする
      return;
    }
    
    // 改めてクライアントサイドでWebWorkerサポートを確認
    this.isSupported = typeof Worker !== 'undefined';
    
    if (!this.isSupported) {
      console.warn(
        '[TypingWorkerManager] WebWorkerがサポートされていません。フォールバックモードを使用します。'
      );
      this.fallbackMode = true;
      this.initialized = true; // フォールバックモードでも初期化完了とする
      return;
    }    try {
      // ワーカーがすでに存在する場合は終了させる
      if (this.worker) {
        this.worker.terminate();
        this.worker = null;
      }      // グローバル参照があれば再利用
      let workerCreated = false;
      if (TypingWorkerRef) {
        try {
          this.worker = TypingWorkerRef;
          console.log('[TypingWorkerManager] グローバル参照のWorkerを使用しています');
          workerCreated = true;
        } catch (importError) {
          console.warn('[TypingWorkerManager] グローバル参照Worker使用失敗:', importError.message);
          TypingWorkerRef = null; // 無効なので参照を削除
        }
      }      // 各種Worker作成戦略を試す
      if (!workerCreated) {
        // 戦略1: 標準的なWorker作成
        if (!workerCreated) {
          this.worker = createWorkerStrategies.standard();
          if (this.worker) {
            console.log('[TypingWorkerManager] 標準的なWorker作成成功');
            workerCreated = true;
            TypingWorkerRef = this.worker;
          }
        }
        
        // 戦略2: URLベースでのWorker作成
        if (!workerCreated) {
          this.worker = createWorkerStrategies.urlBased();
          if (this.worker) {
            console.log('[TypingWorkerManager] URLベースWorker作成成功');
            workerCreated = true;
            TypingWorkerRef = this.worker;
          }
        }
      
        // 通常のWorker作成を試みる
        if (!workerCreated) {
          // Next.js環境向けに絶対URLを使用
          const baseUrl = window.location.origin;
          console.log(`[TypingWorkerManager] ベースURL: ${baseUrl}`);
          
          // 環境に応じたパスの調整（開発環境と本番環境の違いを考慮）
          const isDevelopment = process.env.NODE_ENV === 'development';
          console.log(`[TypingWorkerManager] 環境: ${isDevelopment ? '開発' : '本番'}`);
          
          const possiblePaths = [
            `${baseUrl}/workers/typing-worker.js`,
            '/workers/typing-worker.js',
            isDevelopment ? '/_next/static/workers/typing-worker.js' : null,
            './workers/typing-worker.js',
            '../public/workers/typing-worker.js',
          ].filter(Boolean); // null/undefinedを除去

        // 順番に試す
        for (const workerPath of possiblePaths) {
          try {
            this.worker = new Worker(workerPath);
            console.log(
              `[TypingWorkerManager] Workerを初期化しました: ${workerPath}`
            );
            workerCreated = true;
            // 成功したらグローバル参照を更新
            TypingWorkerRef = this.worker;
            break;
          } catch (pathError) {
            console.warn(
              `[TypingWorkerManager] パス ${workerPath} でWorker作成失敗: ${pathError.message}`
            );
          }
        }
      }// すべてのパスで失敗した場合はインラインWorkerを試す
      if (!workerCreated) {
        console.log('[TypingWorkerManager] インラインWorkerで初期化を試みます');
        try {
          // 拡張されたインラインワーカー実装
          const workerScript = `
            /* eslint-disable */
            // タイピングワーカー - インライン版
            // 初期化完了を通知
            self.postMessage({
              type: 'worker_init',
              data: {
                status: 'initialized',
                timestamp: Date.now(),
                inline: true
              }
            });
            
            // ログユーティリティのインライン実装
            (function() {
              const LOG_LEVELS = { TRACE: 1, DEBUG: 2, INFO: 3, WARN: 4, ERROR: 5, NONE: 6 };
              let currentLogLevel = LOG_LEVELS.INFO;
              let moduleName = 'InlineWorker';
              
              self.workerLogger = {
                setLogLevel: function(level) { 
                  if (typeof level === 'number') currentLogLevel = level; 
                },
                setModuleName: function(name) { 
                  if (typeof name === 'string') moduleName = name; 
                },
                trace: function(...args) { 
                  if (currentLogLevel <= LOG_LEVELS.TRACE) console.log(\`[\${moduleName}:TRACE]\`, ...args); 
                },
                debug: function(...args) { 
                  if (currentLogLevel <= LOG_LEVELS.DEBUG) console.log(\`[\${moduleName}:DEBUG]\`, ...args); 
                },
                info: function(...args) { 
                  if (currentLogLevel <= LOG_LEVELS.INFO) console.log(\`[\${moduleName}:INFO]\`, ...args); 
                },
                warn: function(...args) { 
                  if (currentLogLevel <= LOG_LEVELS.WARN) console.warn(\`[\${moduleName}:WARN]\`, ...args); 
                },
                error: function(...args) { 
                  if (currentLogLevel <= LOG_LEVELS.ERROR) console.error(\`[\${moduleName}:ERROR]\`, ...args); 
                }
              };
            })();
            
            // ロガー設定
            const logger = self.workerLogger;
            logger.setModuleName('TypingInlineWorker');
            logger.setLogLevel(6); // ログ無効化
            
            // キャッシュとメトリクス
            const cache = {
              inputResults: new Map(),
              nextKey: new Map()
            };
            
            const metrics = {
              hits: 0,
              misses: 0,
              processingTime: 0,
              operations: 0,
              lastReset: Date.now()
            };
            
            // 受信したメッセージを処理
            self.onmessage = function(e) {
              try {
                const { type, data, callbackId, priority } = e.data;
                const startTime = performance.now();
                metrics.operations++;
                
                switch(type) {
                  case 'ping':
                    // 疎通確認
                    self.postMessage({
                      type: 'pong',
                      data: { 
                        received: true, 
                        timestamp: Date.now(),
                        originalTime: data?.time,
                        inline: true
                      },
                      callbackId
                    });
                    break;
                    
                  case 'calculateStatistics':
                    // 統計計算（実際のタイピング処理は含まない）
                    const result = {
                      averageKPM: data?.values?.length > 0 
                        ? data.values.reduce((a, b) => a + b, 0) / data.values.length
                        : 0,
                      totalOperations: data?.operations || 0
                    };
                    
                    self.postMessage({
                      type: 'statisticsResult',
                      data: result,
                      callbackId
                    });
                    break;
                    
                  case 'getMetrics':
                    // メトリクス
                    self.postMessage({
                      type: 'metricsResult',
                      data: {
                        ...metrics,
                        timestamp: Date.now(),
                        mode: 'inline'
                      },
                      callbackId
                    });
                    break;
                  
                  case 'PRELOAD_PATTERNS':
                  case 'RESET':
                  case 'CLEAR_INPUT_HISTORY':
                    // 基本操作（キャッシュクリアなど）
                    cache.inputResults.clear();
                    cache.nextKey.clear();
                    self.postMessage({
                      type: 'operationResult',
                      data: { success: true, operation: type },
                      callbackId
                    });
                    break;
                    
                  default:
                    // 不明メッセージ（インラインワーカーは最小限の機能のみ）
                    self.postMessage({
                      type: 'error',
                      error: 'インラインワーカーでは対応していない操作: ' + type,
                      callbackId
                    });
                }
                
                // 処理時間を記録
                metrics.processingTime += performance.now() - startTime;
              } catch (error) {
                self.postMessage({
                  type: 'error',
                  error: error.message || '不明なエラー',
                  callbackId: e.data?.callbackId
                });
              }
            };
          `;
          
          // Blob URLを使用してWorkerを作成
          const workerBlob = new Blob([workerScript], { type: 'application/javascript' });
          const workerBlobUrl = URL.createObjectURL(workerBlob);
          
          this.worker = new Worker(workerBlobUrl);
          console.log('[TypingWorkerManager] インラインWorkerを初期化しました (Blob URL)');
          workerCreated = true;
            // メモリリークを防ぐため、後でBlobを解放するためのURLを保存
          this.workerBlobUrl = workerBlobUrl;
        } catch (inlineError) {
          console.error('[TypingWorkerManager] インラインWorker作成失敗:', inlineError);
          throw new Error('すべてのWorker作成方法が失敗しました: ' + inlineError.message);
        }
      }
      
      // 作成に成功したらグローバル参照を更新
      if (workerCreated) {
        TypingWorkerRef = this.worker;
      }

      // ワーカーからのメッセージを処理
      this.worker.onmessage = (e) => this._handleWorkerMessage(e);

      // エラーハンドリング
      this.worker.onerror = (error) => {
        console.error('[TypingWorkerManager] WorkerError:', error);
        this._reportError('worker_error', error.message || '不明なエラー');

        // エラーメトリクスを記録
        this.metrics.lastErrorTime = Date.now();
        this.metrics.lastErrorMessage = error.message || '不明なエラー';

        // 再初期化（リカバリーロジック）
        if (this.connectionAttempts < 3) {
          this.connectionAttempts++;
          console.log(
            `[TypingWorkerManager] ワーカー再初期化を試行... (${this.connectionAttempts}回目)`
          );
          setTimeout(() => {
            this._initWorker();
          }, 1000);
        } else {
          // 接続試行回数が上限を超えた場合はフォールバックモードに
          console.warn(
            '[TypingWorkerManager] ワーカー接続失敗が続くため、フォールバックモードに切り替えます'
          );
          this.fallbackMode = true;
          this.worker = null;
          this.initialized = true; // フォールバックモードでも初期化完了とする
        }
      };

      // 初期化メッセージを送信してみる（接続確認）
      this._postToWorker('ping', { time: Date.now() }, 'high', (result) => {
        if (result && result.received) {
          this.initialized = true;
          console.log('[TypingWorkerManager] ワーカー初期化完了');

          // 画面のリフレッシュレートを検出してワーカーに通知
          this._detectAndSetDisplayCapabilities();

          // バッファリングされたメッセージを処理
          this._processMessageBuffer();
        }
      });
    } catch (error) {
      console.error('[TypingWorkerManager] 初期化エラー:', error);
      this.fallbackMode = true;
      this.initialized = true;
    }
  }

  /**
   * 画面のリフレッシュレートとシステム能力を検出してワーカーに通知
   */
  _detectAndSetDisplayCapabilities() {
    // リフレッシュレート検出
    let refreshRate = 60; // デフォルト値

    try {
      if (window.screen && window.screen.displayInfo) {
        // 新しいAPI (Chrome 98+)
        refreshRate = window.screen.displayInfo.refreshRate || 60;
      } else if (window.requestAnimationFrame) {
        // おおよその推定（より正確な方法はないため）
        let timestamps = [];
        let measuringFrames = 0;

        const measureRefreshRate = (timestamp) => {
          timestamps.push(timestamp);
          measuringFrames++;

          if (measuringFrames < 50) {
            window.requestAnimationFrame(measureRefreshRate);
          } else {
            // 平均フレーム時間から計算
            const deltas = [];
            for (let i = 1; i < timestamps.length; i++) {
              deltas.push(timestamps[i] - timestamps[i - 1]);
            }

            const avgDelta =
              deltas.reduce((sum, delta) => sum + delta, 0) / deltas.length;
            refreshRate = Math.round(1000 / avgDelta);

            // 検出したリフレッシュレートをワーカーに送信
            this._sendDisplayCapabilities(refreshRate);
          }
        };

        window.requestAnimationFrame(measureRefreshRate);
      }
    } catch (e) {
      console.warn('[TypingWorkerManager] リフレッシュレート検出エラー:', e);
      // エラーが発生した場合はデフォルト値を使用
      this._sendDisplayCapabilities(refreshRate);
    }
  }

  /**
   * 検出した画面機能をワーカーに送信
   */
  _sendDisplayCapabilities(refreshRate) {
    const capabilities = {
      refreshRate,
      supportsSharedArrayBuffer: typeof SharedArrayBuffer !== 'undefined',
      devicePixelRatio: window.devicePixelRatio || 1,
      lowPowerMode: navigator.deviceMemory ? navigator.deviceMemory < 4 : false,
    };

    this._postToWorker(
      'setDisplayCapabilities',
      capabilities,
      'normal',
      (result) => {
        console.log(
          '[TypingWorkerManager] ディスプレイ機能を設定しました:',
          result?.appliedSettings || 'unknown'
        );
      }
    );
  }

  /**
   * ワーカーメッセージハンドラ
   * @param {MessageEvent} e ワーカーからのメッセージイベント
   */
  _handleWorkerMessage(e) {
    try {
      // メッセージ受信カウントを増やす
      this.metrics.totalMessagesReceived++;

      const { type, data, callbackId, error } = e.data;

      // 未知のメッセージタイプの場合は無視
      if (!type) {
        console.warn('[TypingWorkerManager] 未知のワーカーメッセージ:', e.data);
        return;
      }

      // タイプに応じた処理
      switch (type) {
        case 'worker_init':
          // Worker初期化メッセージ - 特に何もしない
          break;

        case 'worker_error':
          // Workerエラーメッセージ
          console.error(
            '[TypingWorkerManager] ワーカーエラー:',
            data?.error || error || 'Unknown error'
          );
          // エラーメトリクスを記録
          this.metrics.lastErrorTime = Date.now();
          this.metrics.lastErrorMessage =
            data?.error || error || 'Unknown error';
          break;

        case 'pong':
          // ping応答
          // コールバックがあれば呼び出す
          if (callbackId && this.callbacks.has(callbackId)) {
            const callback = this.callbacks.get(callbackId);
            callback(data);
            this.callbacks.delete(callbackId);
            this.metrics.activeCallbacks--;
          }
          break;

        case 'next_key_result':
          // 次のキー取得結果
          // 高速アクセスのために共有状態を更新
          if (data && data.key !== undefined) {
            this.sharedState.nextExpectedKey = data.key;
            this.sharedState.lastUpdateTimestamp = Date.now();
          }

          // コールバックがあれば呼び出す
          if (callbackId && this.callbacks.has(callbackId)) {
            const callback = this.callbacks.get(callbackId);
            if (error) {
              callback(null, error);
            } else {
              callback(data);
            }
            this.callbacks.delete(callbackId);
            this.metrics.activeCallbacks--;
          }
          break;

        default:
          // その他のメッセージ
          // コールバックがあれば呼び出す
          if (callbackId && this.callbacks.has(callbackId)) {
            const callback = this.callbacks.get(callbackId);
            if (error) {
              callback(null, error);
            } else {
              callback(data);
            }
            this.callbacks.delete(callbackId);
            this.metrics.activeCallbacks--;
          } else {
            console.warn(
              '[TypingWorkerManager] コールバックが見つかりません:',
              callbackId
            );
          }
      }
    } catch (error) {
      console.error('[TypingWorkerManager] メッセージ処理エラー:', error);
    }
  }

  /**
   * ワーカーにメッセージを送信
   * @param {string} type メッセージタイプ
   * @param {*} data 送信データ
   * @param {'normal'|'high'|'low'} priority 優先度
   * @param {Function} callback コールバック関数
   * @returns {Promise<*>} 処理結果
   */
  _postToWorker(type, data, priority = 'normal', callback) {
    return new Promise((resolve, reject) => {
      try {
        // ワーカーが初期化されていない場合はバッファリングする
        if (!this.initialized) {
          this.messageBuffer.push({
            type,
            data,
            priority,
            callback,
            resolve,
            reject,
          });
          return;
        }

        // フォールバックモードならエラー
        if (this.fallbackMode) {
          const error = new Error('WebWorker非対応環境');
          if (callback) callback(null, error);
          reject(error);
          return;
        }

        // コールバックIDを生成
        const callbackId = this.nextCallbackId++;

        // 高優先度の場合はメトリクスを記録
        if (priority === 'high') {
          this.metrics.highPriorityOperations++;
        }

        // コールバック関数を登録
        if (callback) {
          this.callbacks.set(callbackId, (result, error) => {
            if (error) {
              reject(error);
            } else {
              resolve(result);
            }
            if (callback) callback(result, error);
          });
          this.metrics.activeCallbacks++;
        }

        // ワーカーにメッセージを送信
        this.worker.postMessage({
          type,
          data,
          callbackId,
          priority,
        });

        // メトリクスを更新
        this.metrics.totalMessagesSent++;
      } catch (error) {
        console.error('[TypingWorkerManager] メッセージ送信エラー:', error);
        if (callback) callback(null, error);
        reject(error);
      }
    });
  }

  /**
   * バッファリングされたメッセージを処理
   */
  _processMessageBuffer() {
    if (this.messageBuffer.length > 0) {
      console.log(
        `[TypingWorkerManager] バッファリングされた${this.messageBuffer.length}件のメッセージを処理します`
      );

      // バッファリングされたメッセージを全て処理
      for (const message of this.messageBuffer) {
        const { type, data, priority, callback, resolve, reject } = message;
        this._postToWorker(type, data, priority, (result, error) => {
          if (error) {
            if (callback) callback(null, error);
            reject(error);
          } else {
            if (callback) callback(result);
            resolve(result);
          }
        });
      }

      // バッファをクリア
      this.messageBuffer = [];
    }
  }

  /**
   * エラー報告
   * @param {string} type エラータイプ
   * @param {string} message エラーメッセージ
   */
  _reportError(type, message) {
    console.error(`[TypingWorkerManager] ${type}: ${message}`);
    // エラーメトリクスを記録
    this.metrics.lastErrorTime = Date.now();
    this.metrics.lastErrorMessage = message;
  }  /**
   * 入力を処理し、結果を返す
   * @param {Object} session タイピングセッション
   * @param {string} char 入力された文字
   * @returns {Promise<Object>} 処理結果
   */
  processInput(session, char) {
    // セッションとキャラクターの簡易チェック
    if (!session || !char) {
      return Promise.reject(new Error('無効な入力'));
    }

    // キャッシュキーを作成
    const cacheKey = `${session.currentCharIndex}_${session.currentInput || ''
      }_${char}`;

    // キャッシュチェック
    if (this.cache.inputResults.has(cacheKey)) {
      this.metrics.cacheHits++;
      return Promise.resolve(this.cache.inputResults.get(cacheKey));
    }

    this.metrics.cacheMisses++;
    this.metrics.processCalls++;

    const startTime = performance.now();

    // タイピング処理は常にメインスレッドで実行
    this.metrics.mainThreadProcessCalls++;

    try {
      const result = processTypingInputOnMainThread(session, char);
      const processingTime = performance.now() - startTime;
      this.metrics.mainThreadProcessingTime += processingTime;
      this.metrics.processingTime += processingTime;

      if (result && result.success !== false) {
        this.cache.inputResults.set(cacheKey, result);
        if (this.cache.inputResults.size > 1000) {
          const keys = Array.from(this.cache.inputResults.keys()).slice(0, 200);
          for (const key of keys) {
            this.cache.inputResults.delete(key);
          }
        }
      }
      return Promise.resolve(result);
    } catch (error) {
      console.error('メインスレッド処理エラー:', error);
      return Promise.reject(error); // Web Workerへのフォールバックを削除
    }
  }

  getColoringInfo(session) {
    if (!session) {
      return Promise.reject(new Error('無効なセッション'));
    }

    const cacheKey = `color_${session.currentCharIndex || 0}_${session.currentInput || ''
      }_${session.completed ? 1 : 0}`;

    if (this.cache.coloringInfo.has(cacheKey)) {
      this.metrics.cacheHits++;
      return Promise.resolve(this.cache.coloringInfo.get(cacheKey));
    }

    this.metrics.cacheMisses++;

    // タイピング関連の表示情報は常にメインスレッドで処理
    this.metrics.mainThreadProcessCalls++;
    try {
      const result = getColoringInfoOnMainThread(session);
      if (result && !result.error) {
        this.cache.coloringInfo.set(cacheKey, result);
        if (this.cache.coloringInfo.size > 500) { // 修正点: 括弧を追加
          const keys = Array.from(this.cache.coloringInfo.keys()).slice(0, 100);
          for (const key of keys) {
            this.cache.coloringInfo.delete(key);
          }
        }
      }
      return Promise.resolve(result);
    } catch (error) {
      console.error('メインスレッド処理エラー (色分け情報):', error);
      return Promise.reject(error); // Web Workerへのフォールバックを削除
    }
  }

  getNextExpectedKey(session) {
    if (!session) {
      return Promise.reject(new Error('無効なセッション'));
    }

    if (session.completed) {
      return Promise.resolve({ key: '' });
    }

    const now = Date.now();
    if (
      this.sharedState.lastUpdateTimestamp > now - 1 &&
      this.sharedState.nextExpectedKey
    ) {
      return Promise.resolve({ key: this.sharedState.nextExpectedKey });
    }

    // タイピング関連のキー取得は常にメインスレッドで処理
    this.metrics.mainThreadProcessCalls++;
    try {
      const result = getNextExpectedKeyOnMainThread(session);
      if (result && result.key !== undefined) {
        this.sharedState.nextExpectedKey = result.key;
        this.sharedState.lastUpdateTimestamp = now;
      }
      return Promise.resolve(result);
    } catch (error) {
      console.error('メインスレッド処理エラー (次のキー):', error);
      return Promise.reject(error); // Web Workerへのフォールバックを削除
    }
  }

  /**
   * 統計を計算
   * @param {Object} data 統計計算用データ
   * @returns {Promise<Object>} 統計結果
   */
  calculateStatistics(data) {
    if (!data) {
      return Promise.reject(new Error('無効なデータ'));
    }

    // ワーカーに統計計算メッセージを送信
    return this._postToWorker('calculateStatistics', data, 'normal');
  }

  /**
   * ランキングを送信
   * @param {Object} data ランキングデータ
   * @returns {Promise<Object>} 送信結果
   */
  submitRanking(data) {
    if (!data) {
      return Promise.reject(new Error('無効なデータ'));
    }

    // ワーカーにランキング送信メッセージを送信
    return this._postToWorker('submitRanking', data, 'low');
  }

  /**
   * パターンを事前ロード
   * @param {Array} patterns パターン配列
   * @returns {Promise<Object>} ロード結果
   */
  preloadPatterns(patterns) {
    if (!patterns || !Array.isArray(patterns)) {
      return Promise.reject(new Error('無効なパターン'));
    }

    // ワーカーにパターン事前ロードメッセージを送信
    return this._postToWorker('PRELOAD_PATTERNS', { patterns }, 'normal');
  }
  /**
   * リセット
   * @returns {Promise<Object>} リセット結果
   */  reset() {
    // キャッシュをクリア
    this.cache.inputResults.clear();
    this.cache.coloringInfo.clear();

    // 共有状態をリセット
    this.sharedState.nextExpectedKey = '';
    this.sharedState.inputMode = 'normal';
    this.sharedState.lastUpdateTimestamp = 0;

    // メインスレッド処理のキャッシュもクリア
    if (typeof clearMainThreadCache === 'function') {
      clearMainThreadCache();
    }

    // ワーカーにリセットメッセージを送信
    return this._postToWorker('RESET', null, 'high');
  }

  /**
   * 処理モードを設定
   * @param {Object} modes 処理モード設定
   * @returns {Promise<Object>} 設定結果
   */
  setProcessingModes(modes) {
    if (!modes || typeof modes !== 'object') {
      return Promise.reject(new Error('無効なモード設定'));
    }

    // 現在のモードをバックアップ
    const previousModes = { ...this.processingMode };

    // モードを更新
    if (modes.typing === 'worker' || modes.typing === 'main-thread') {
      this.processingMode.typing = modes.typing;
    }

    if (modes.effects === 'worker' || modes.effects === 'main-thread') {
      this.processingMode.effects = modes.effects;
    }

    if (modes.statistics === 'worker' || modes.statistics === 'main-thread') {
      this.processingMode.statistics = modes.statistics;
    }

    // モード変更ログ
    console.log('[TypingWorkerManager] 処理モード変更:', this.processingMode);

    // モードが変わった場合はキャッシュをクリア
    if (previousModes.typing !== this.processingMode.typing) {
      this.cache.inputResults.clear();
      this.cache.coloringInfo.clear();

      if (typeof clearMainThreadCache === 'function') {
        clearMainThreadCache();
      }
    }

    return Promise.resolve({
      success: true,
      currentModes: { ...this.processingMode },
      previousModes
    });
  }

  /**
   * 入力履歴をクリア
   * @returns {Promise<Object>} クリア結果
   */
  clearInputHistory() {
    // 入力関連のキャッシュをクリア
    this.cache.inputResults.clear();

    // ワーカーに入力履歴クリアメッセージを送信
    return this._postToWorker('CLEAR_INPUT_HISTORY', null, 'normal');
  }

  /**
   * 最適化オプションを更新
   * @param {Object} options 最適化オプション
   * @returns {Promise<Object>} 更新結果
   */
  updateOptimizationOptions(options) {
    if (!options || typeof options !== 'object') {
      return Promise.reject(new Error('無効なオプション'));
    }

    // ワーカーに最適化オプション更新メッセージを送信
    return this._postToWorker('updateOptimizationOptions', options, 'normal');
  }

  /**
   * パフォーマンスメトリクスを取得
   * @returns {Promise<Object>} メトリクス
   */
  getPerformanceMetrics() {
    // 現在のメトリクスのコピーを作成
    const currentMetrics = { ...this.metrics };

    // メトリクスを蓄積するオブジェクト
    let combinedMetrics = {
      ...currentMetrics,
      timestamp: Date.now(),
      uptime: Date.now() - (this.metrics.lastSync || Date.now()),
      callbacksCount: this.callbacks.size,
      cacheSize: {
        inputResults: this.cache.inputResults.size,
        coloringInfo: this.cache.coloringInfo.size,
      },
    };

    // ワーカーからもメトリクスを取得して統合
    return this._postToWorker('getMetrics', null, 'low')
      .then((workerMetrics) => {
        // ワーカーメトリクスと統合
        combinedMetrics.workerMetrics = workerMetrics;

        // キャッシュヒット率計算
        const totalCalls =
          combinedMetrics.cacheHits + combinedMetrics.cacheMisses;
        combinedMetrics.cacheHitRatio =
          totalCalls > 0 ? combinedMetrics.cacheHits / totalCalls : 0;

        // メトリクスを保存
        this.metrics.lastPerformanceReport = combinedMetrics;

        return combinedMetrics;
      })
      .catch((error) => {
        // ワーカーからのメトリクス取得に失敗した場合は現在のメトリクスだけを返す
        console.warn(
          '[TypingWorkerManager] ワーカーメトリクス取得エラー:',
          error
        );
        return combinedMetrics;
      });
  }

  /**
   * 複数の操作をバッチ処理
   * @param {Array} operations 処理する操作配列
   * @returns {Promise<Object>} バッチ処理結果
   */
  processBatch(operations) {
    if (!operations || !Array.isArray(operations)) {
      return Promise.reject(new Error('無効なバッチ操作'));
    }

    // バッチ操作カウントを増やす
    this.metrics.batchOperations++;

    // ワーカーにバッチ処理メッセージを送信
    return this._postToWorker('batch', operations, 'normal');
  }

  /**
   * メインスレッドでのタイピング入力処理
   * @param {Object} session タイピングセッション
   * @param {string} char 入力された文字
   * @returns {Promise<Object>} 処理結果
   */
  processTypingInput(session, char) {
    return new Promise((resolve, reject) => {
      try {
        // セッションとキャラクターの簡易チェック
        if (!session || !char) {
          return reject(new Error('無効な入力'));
        }

        this.metrics.mainThreadProcessCalls++;

        const startTime = performance.now();

        // メインスレッドで直接処理
        const result = processTypingInputOnMainThread(session, char);

        // 処理時間をメトリクスに追加
        this.metrics.mainThreadProcessingTime +=
          performance.now() - startTime;

        resolve(result);
      } catch (error) {
        console.error('[TypingWorkerManager] メインスレッド処理エラー:', error);
        reject(error);
      }
    });
  }

  /**
   * メインスレッドでの色分け情報取得
   * @param {Object} session タイピングセッション
   * @returns {Promise<Object>} 色分け情報
   */  getColoringInfoMainThread(session) {
    return new Promise((resolve, reject) => {
      try {
        if (!session) {
          return reject(new Error('無効なセッション'));
        }

        // メインスレッドで直接処理
        const result = getColoringInfoOnMainThread(session);

        resolve(result);
      } catch (error) {
        console.error('[TypingWorkerManager] メインスレッド色分け処理エラー:', error);
        reject(error);
      }
    });
  }
  
  /**
   * リソースのクリーンアップ
   * コンポーネントのアンマウント時などに呼び出す
   */  cleanup() {
    if (this.worker) {
      this.worker.terminate();
      this.worker = null;
    }
    
    // グローバル参照をクリア
    TypingWorkerRef = null;
    
    // BlobURLを解放
    if (this.workerBlobUrl) {
      URL.revokeObjectURL(this.workerBlobUrl);
      this.workerBlobUrl = null;
    }
    
    this.callbacks.clear();
    this.messageBuffer = [];
    this.queue = [];
    this.initialized = false;
    this.fallbackMode = false;
    this.connectionAttempts = 0;
    
    // キャッシュをクリア
    this.cache.inputResults.clear();
    this.cache.coloringInfo.clear();
    
    // 共有状態をリセット
    this.sharedState.nextExpectedKey = '';
    this.sharedState.inputMode = 'normal';
    this.sharedState.lastUpdateTimestamp = 0;
    
    console.log('[TypingWorkerManager] リソースをクリーンアップしました');
  }
}

// シングルトンインスタンスを作成
const typingWorkerManager = new TypingWorkerManager();

export default typingWorkerManager;
